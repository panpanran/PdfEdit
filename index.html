<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Upload, Inline Annotation & Download</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { 
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
        margin: 16px auto; 
        max-width: 1000px; 
    }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:flex-start; margin-bottom:12px; } 
    .page-controls { display:flex; gap:8px; align-items:center; }
    .page-container { border:1px solid #ddd; margin-bottom: 10px; } 
    .tools { display:flex; gap:8px; align-items:center; }
    .label { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    .row { margin:8px 0; }
    
    /* 1. æŒ‰é’®åŸºç¡€æ ·å¼ */
    button, input, select { 
        padding:6px 10px; 
        font-size:14px; 
    }
    
    /* é‡ç‚¹ä¿®æ”¹ï¼šç»Ÿä¸€å·¥å…·æŒ‰é’®å°ºå¯¸å’Œæ ·å¼ */
    .tools button, .page-controls button { 
        width: 40px; /* Consistent width */
        height: 40px; /* Consistent height */
        padding: 0; /* Remove padding for better icon centering */
        font-size: 20px; /* Larger size for icons */
        line-height: 40px; /* Center vertical */
        flex-grow: 0; /* Prevent buttons from growing */
        text-align: center; 
        box-sizing: border-box; /* Include border/padding in size */
    }
    
    .tool-active { background:#1f6feb; color:white; }
    
    /* é’ˆå¯¹ç‰¹æ®Šæ§ä»¶è¿›è¡Œå°ºå¯¸è°ƒæ•´ */
    .tools input[type="color"] { width: 40px; height: 40px; padding: 2px; flex-grow: 0; }
    #fontSize { 
        width: 60px; 
        height: 40px; 
        padding: 0 4px; 
        line-height: normal; /* Override line-height for select */
        font-size: 14px; 
        flex-grow: 0;
    } 
    /* ä¸‹è½½æŒ‰é’®å¯ä»¥ç•¥å¾®å¤§ä¸€ç‚¹ */
    #downloadBtn { 
        width: auto; 
        min-width: 40px; 
        padding: 0 10px; 
        font-size: 16px; 
        line-height: normal; 
        height: 40px; 
    } 

    #pdf-viewer-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center; 
        width: 100%;
        cursor: default; 
    }
    
    .page-wrapper {
        position: relative; 
        display: inline-block; 
        margin-bottom: 10px; 
        box-shadow: 0 0 5px rgba(0,0,0,0.1);
        cursor: default; 
    }
    
    .pdfCanvas, .annoCanvas {
        display: block;
    }

    /* Annotation Canvas Overlay */
    .annoCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 5; 
        pointer-events: auto; 
    }

    /* Text Layer æ ·å¼ */
    .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        z-index: 2; 
        line-height: 1.0;
        color: transparent; 
        user-select: text; 
        -webkit-user-select: text;
        -webkit-touch-callout: default;
        pointer-events: none; 
    }
    
    /* å½“é€‰ä¸­ 'Select Text' æˆ– 'Highlight' å·¥å…·æ—¶ï¼Œä¸º Text Layer å¯ç”¨ç‚¹å‡»/é€‰ä¸­ */
    .page-wrapper.select-text-active .textLayer {
        pointer-events: auto;
        z-index: 10;              /* iOS ä¸Šæ›´ç¨³ï¼šç¡®ä¿ textLayer åœ¨æœ€ä¸Šå±‚æ¥æ”¶è§¦æ‘¸ */
    }

    /* ç¡®ä¿åœ¨é€‰ä¸­æ¨¡å¼ä¸‹ï¼Œæ³¨é‡Šå±‚ä¸æ‹¦æˆªè§¦æ‘¸ï¼ˆå¹¶ä¸‹æ²‰åˆ° textLayer ä¸‹é¢ï¼‰ */
    .page-wrapper.select-text-active .annoCanvas {
        pointer-events: none !important;
        z-index: 1;
    }
    /* iOS/Android: make sure selection is not blocked by ancestor styles */
    .page-wrapper.select-text-active {
        -webkit-user-select: text;
        user-select: text;
    }
    .page-wrapper.select-text-active .textLayer > div {
        pointer-events: auto;
        -webkit-user-select: text;
        user-select: text;
        -webkit-touch-callout: default;
    }
.textLayer > div {
        position: absolute;
        white-space: pre;
        transform-origin: 0% 0%;
        cursor: text !important; 
    }
    
    /* æ–‡æœ¬é€‰ä¸­è§†è§‰åé¦ˆï¼šæµ…è“è‰²èƒŒæ™¯ */
    .textLayer ::selection {
      background: rgba(173, 216, 230, 0.5); 
      color: inherit;
    }
    .textLayer ::-moz-selection {
      background: rgba(173, 216, 230, 0.5); 
      color: inherit;
    }

    /* Dynamic text input for inline editing */
    #annotationInput {
        position: absolute; 
        border: 1px dashed black; 
        box-sizing: content-box;
        padding: 0;
        margin: 0;
        line-height: 1.2; 
        background: rgba(255, 255, 255, 0.9);
        z-index: 100;
        resize: none; 
        overflow: hidden; 
    }
    
    /* æ‹–åŠ¨é¢„è§ˆå…ƒç´ æ ·å¼ */
    #dragPreview {
        display: none; 
        position: absolute; 
        z-index: 99;
        white-space: pre-wrap;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
        line-height: 1.2;
        background: rgba(255, 255, 255, 0.8);
        pointer-events: none; 
    }

    /* Signature Modal Styles (omitted for brevity, assume unchanged) */
    #signatureModal {
        display: none; 
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4); 
        padding-top: 50px;
    }
    #signatureContent {
        background-color: #fefefe;
        margin: 5% auto; 
        padding: 20px;
        border: 1px solid #888;
        width: 80%; 
        max-width: 600px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    }
    #signaturePadCanvas {
        border: 1px solid #000;
        background: #fff;
        display: block;
        cursor: crosshair;
        width: 100%; 
        height: 200px; 
    }
    .modal-buttons {
        margin-top: 10px;
        text-align: right;
    }

    /* ç§»åŠ¨è®¾å¤‡å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 600px) {
        body { margin: 8px; }
        .toolbar { flex-direction: column; gap: 12px; align-items: flex-start; }
        .row, .page-controls, .tools { width: 100%; box-sizing: border-box; }
        .tools { flex-wrap: wrap; flex-direction: row; gap: 6px; }
        .tools button { flex-grow: 1; min-width: 36px; max-width: none; } /* ç§»åŠ¨ç«¯æ”¾å¼€ max-width */
        .tools input[type="color"] { width: 36px; height: 36px; padding: 2px; flex-grow: 0; }
        #fontSize { width: 60px; flex-grow: 0; }
        .page-controls { flex-wrap: wrap; gap: 8px; }
        .page-controls input { width: 60px !important; }
        .page-wrapper { width: 100% !important; max-width: 100%; }
        .pdfCanvas, .annoCanvas, .textLayer {
            width: 100% !important; 
            height: auto !important; 
            max-width: 100%;
        }
    }
    
  </style>
  <meta name="google-adsense-account" content="ca-pub-7563681675733550">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7563681675733550"
     crossorigin="anonymous"></script>
</head>
<body>
  <h2>PDF Upload, Inline Annotation & Download</h2>

  <div class="toolbar">
    <div class="row">
      <span class="label">Choose PDF:</span>
      <input type="file" id="fileInput" accept="application/pdf" />
    </div>
    
    <div class="page-controls">
      <span class="label">Total Pages: <span id="pageCount">0</span></span>
      <label for="pageInput">Go to Page:</label>
      <input type="number" id="pageInput" min="1" value="1" style="width: 50px;" disabled />
      <button id="goToPageBtn" disabled title="Go">â¡ï¸</button>
    </div>

    <div class="tools">
      <span class="label">Tools:</span>
      <button id="toolMouse" title="Select/Move">ğŸ–±ï¸</button> 
      <button id="toolSelectText" title="Select Text">I</button> 
      <button id="toolText" title="Add Text">T</button>
      <button id="toolHighlight" title="Highlight">ğŸ–ï¸</button>
      <button id="toolSignature" title="Signature">âœï¸</button>
      <button id="toolDelete" title="Delete">ğŸ—‘ï¸</button>
      <input id="colorInput" type="color" value="#ff0000" title="Color" />
      <select id="fontSize">
        <option value="12">12px</option>
        <option value="14" selected>14px</option>
        <option value="18">18px</option>
        <option value="24">24px</option>
        <option value="32">32px</option>
      </select>
	  <button id="undoBtn" disabled title="Undo">â†©ï¸</button>
      <button id="redoBtn" disabled title="Redo">â†ªï¸</button>
      <button id="downloadBtn" disabled title="Download">â¬‡ï¸</button>
    </div>
  </div>

  <div class="hint">Tip: Use mouse wheel or arrow keys to scroll through pages. ğŸ–±ï¸ = Select/Move existing Text or Signature. I = Select text on the PDF (I-beam cursor). T = click to place, DOUBLE-CLICK to edit, drag to move. ğŸ–ï¸ = select text to highlight. âœï¸ = open signature pad. ğŸ—‘ï¸ = click on an annotation to remove.</div>

  <div id="pdf-viewer-wrapper">
    </div>

  <textarea id="annotationInput" style="display:none;"></textarea>
  <div id="dragPreview"></div> 
  
  <div id="signatureModal">
      <div id="signatureContent">
          <h3>Draw Your Signature</h3>
          <canvas id="signaturePadCanvas" width="560" height="200"></canvas>
          <div class="modal-buttons">
              <button id="clearSignatureBtn">Clear</button>
              <button id="saveSignatureBtn">Save and Place</button>
              <button id="closeSignatureBtn">Cancel</button>
          </div>
      </div>
  </div>
  
  <div style="margin-top: 30px; padding: 20px; text-align: center; border-top: 1px solid #ddd;">
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-7563681675733550"
     data-ad-slot="9227935901"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle || []).push({});
</script>
  </div>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FCQP2T463K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FCQP2T463K');
</script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    const fileInput = document.getElementById('fileInput');
    const pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');
    const pageCountSpan = document.getElementById('pageCount');

    const toolMouseBtn = document.getElementById('toolMouse'); 
    const toolSelectTextBtn = document.getElementById('toolSelectText'); 
    const toolTextBtn = document.getElementById('toolText');
    const toolHighlightBtn = document.getElementById('toolHighlight');
    const toolDeleteBtn = document.getElementById('toolDelete');
    const toolSignatureBtn = document.getElementById('toolSignature');

    const colorInput = document.getElementById('colorInput');
    const fontSizeSelect = document.getElementById('fontSize');
    const downloadBtn = document.getElementById('downloadBtn');
    const undoBtn = document.getElementById('undoBtn'); 
    const redoBtn = document.getElementById('redoBtn'); 
    const annotationInput = document.getElementById('annotationInput'); 
    const dragPreview = document.getElementById('dragPreview'); 
    const pdfLib = window.PDFLib;
    const pageInput = document.getElementById('pageInput');
    const goToPageBtn = document.getElementById('goToPageBtn');
    
    // Signature Elements
    const signatureModal = document.getElementById('signatureModal');
    const signaturePadCanvas = document.getElementById('signaturePadCanvas');
    const clearSignatureBtn = document.getElementById('clearSignatureBtn');
    const saveSignatureBtn = document.getElementById('saveSignatureBtn');
    const closeSignatureBtn = document.getElementById('closeSignatureBtn');
    let signatureCtx = signaturePadCanvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // Cache for signature images to ensure synchronous drawing
    let signatureImageCache = new Map();


    let pdfDoc = null;
    let originalFile = null; // FIX: å…¨å±€å˜é‡ç”¨äºå­˜å‚¨åŸå§‹æ–‡ä»¶å¯¹è±¡
    let annotations = []; 
    let history = []; 
    let redoHistory = [];
    const MAX_HISTORY = 10; 

    let currentTool = 'mouse'; // DEFAULT TO MOUSE/MOVE TOOL 
    let dragStart = null; 
    let dragEnd = null;
    
    let activeAnno = null; 
    let activeAnnoPage = -1; 
    let activeAnnoCanvas = null; 
    let activePageWrapper = null; 

    let dragAnno = null; 
    let dragOffset = {x: 0, y: 0}; 
    let isDragging = false; 
    
    // çŠ¶æ€å˜é‡ï¼šç”¨äºå­˜å‚¨ Signature æ”¾ç½®ä½ç½®
    let signaturePlacementPos = null;
    let signaturePlacementPageNum = -1;

    annotationInput.addEventListener('blur', (e) => {
        if (activeAnno) {
            (async () => {
                 await finalizeText();
            })();
        }
    });
    
    // --- ä¿®å¤ 1: æ–‡æœ¬æ³¨é‡Šçš„é¢œè‰²å’Œå¤§å°ä¸è·Ÿéšå·¥å…·æ å˜åŠ¨ ---
    colorInput.addEventListener('change', (e) => {
        // 1. å®æ—¶æ›´æ–°æ­£åœ¨ç¼–è¾‘çš„æ–‡æœ¬æ³¨é‡Š (Text Annotation) çš„å±æ€§å’Œæ ·å¼
        if (activeAnno && activeAnno.type === 'text') {
            saveState(); 
            activeAnno.color = e.target.value;
            annotationInput.style.color = e.target.value;
            annotationInput.style.borderColor = e.target.value;
        }
    });

    fontSizeSelect.addEventListener('change', (e) => {
        // 1. å®æ—¶æ›´æ–°æ­£åœ¨ç¼–è¾‘çš„æ–‡æœ¬æ³¨é‡Š (Text Annotation) çš„å±æ€§å’Œæ ·å¼
        if (activeAnno && activeAnno.type === 'text') {
            saveState(); 
            const newSize = parseInt(e.target.value, 10);
            activeAnno.fontSize = newSize;
            annotationInput.style.fontSize = `${newSize}px`;
            // ç¡®ä¿ line-height ä¹Ÿè·Ÿç€å˜åŒ–
            annotationInput.style.lineHeight = `${newSize * 1.2}px`; 
        }
    });
    // --- ä¿®å¤ 1 ç»“æŸ ---
    
    
    // --- NEW: Function to control the pointer events and cursor ---
    function updateAnnotationCanvasPointerEvents(toolName) {
        const pageWrappers = document.querySelectorAll('.page-wrapper');
        // å…³é”®ï¼šå½“ toolName ä¸º 'select_text' æˆ– 'highlight' æ—¶ï¼Œè®¾ç½®å…‰æ ‡ä¸º text (Iå½¢å…‰æ ‡)
        const newCursor = (toolName === 'select_text' || toolName === 'highlight') ? 'text' : 'default'; 
        
        pageWrappers.forEach(pageWrapper => {
            // å…³é”®ä¿®æ­£ï¼šå°†å…‰æ ‡æ ·å¼åº”ç”¨åˆ°çˆ¶å®¹å™¨ (.page-wrapper)
            pageWrapper.style.cursor = newCursor; 

            // é€šè¿‡åˆ‡æ¢ class æ¥æ§åˆ¶ textLayer å’Œ annoCanvas çš„ pointer-events
            if (toolName === 'select_text' || toolName === 'highlight') { // <--- å¢åŠ äº†å¯¹ Highlight å·¥å…·çš„æ£€æŸ¥
                 pageWrapper.classList.add('select-text-active');
            } else {
                 pageWrapper.classList.remove('select-text-active');
            }
        });
        
        // ç¡®ä¿ä¸»å®¹å™¨å…‰æ ‡é‡ç½®
        pdfViewerWrapper.style.cursor = 'default';
    }


    function setTool(button, toolName) {
      if (activeAnno) {
          (async () => { await finalizeText(); })();
      }
      
      dragAnno = null;
      dragStart = null;
      isDragging = false;
      dragPreview.style.display = 'none'; 
      
      // åˆ‡æ¢å·¥å…·æ—¶é‡ç½®ç­¾åæ”¾ç½®åæ ‡
      signaturePlacementPos = null;
      signaturePlacementPageNum = -1;
      
      // æ›´æ–°æŒ‰é’®åˆ—è¡¨
      [toolMouseBtn, toolSelectTextBtn, toolTextBtn, toolHighlightBtn, toolDeleteBtn, toolSignatureBtn].forEach(b => b.classList.remove('tool-active')); 
      button.classList.add('tool-active');
      currentTool = toolName;
      
      if (toolName === 'highlight') {
        colorInput.value = '#ffff00'; // ç¡®ä¿é«˜äº®å·¥å…·ä½¿ç”¨é»„è‰²
      }
      
      // å…³é”®ï¼šæ›´æ–°æ‰€æœ‰ annotation canvas çš„ pointer-events å±æ€§
      updateAnnotationCanvasPointerEvents(currentTool); 
    }

    // Mobile fix: bind both click and touchstart for tool buttons (some mobile browsers delay/suppress click)
    function bindToolButton(btn, toolName) {
      btn.onclick = () => setTool(btn, toolName);
      btn.addEventListener('touchstart', (e) => {
        // Prevent the touch from also triggering scroll/zoom gestures on the toolbar,
        // and switch tools immediately.
        e.preventDefault();
        setTool(btn, toolName);
      }, { passive: false });
    }

    bindToolButton(toolMouseBtn, 'mouse');
    bindToolButton(toolSelectTextBtn, 'select_text');
    bindToolButton(toolTextBtn, 'text');
    bindToolButton(toolHighlightBtn, 'highlight');
    bindToolButton(toolDeleteBtn, 'delete');
    bindToolButton(toolSignatureBtn, 'signature');

    function isMobileDevice() {
        // æ£€æŸ¥å¸¸è§çš„ç§»åŠ¨è®¾å¤‡ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸² æˆ– æ£€æŸ¥æ˜¯å¦å­˜åœ¨è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
    }

    document.addEventListener('DOMContentLoaded', () => {
        toolMouseBtn.click(); // é»˜è®¤å¯ç”¨é¼ æ ‡å·¥å…·
        
        // NEW: å¦‚æœæ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œéšè— Select Text å’Œ Highlight å·¥å…·
        if (isMobileDevice()) {
            toolSelectTextBtn.style.display = 'none';
            toolHighlightBtn.style.display = 'none';
            
            // ç®€åŒ–æç¤ºä¿¡æ¯
            const hintElement = document.querySelector('.hint');
            if (hintElement) {
                 // ç§»é™¤ä¸ Select Text (I) å’Œ Highlight (ğŸ–ï¸) ç›¸å…³çš„å†…å®¹
                 hintElement.innerHTML = 'Tip: Use arrow keys to scroll through pages. ğŸ–±ï¸ = Select/Move existing Text or Signature. T = click to place, DOUBLE-CLICK to edit, drag to move. âœï¸ = open signature pad. ğŸ—‘ï¸ = click on an annotation to remove.';
            }
        }
    });

    // --- History Functions (omitted for brevity, assume unchanged) ---
    function saveState() {
        const newState = JSON.parse(JSON.stringify(annotations));
        if (history.length > 0 && JSON.stringify(history[history.length - 1]) === JSON.stringify(newState)) {
            return;
        }
        
        history.push(newState);
        if (history.length > MAX_HISTORY) {
            history.shift();
        }
        redoHistory = []; 
        updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
        undoBtn.disabled = history.length <= 1; 
        redoBtn.disabled = redoHistory.length === 0;
    }
    
    async function preloadSignatureImages() {
        const imagePromises = [];

        for (const pageAnnos of annotations) {
            for (const a of pageAnnos) {
                if (a.type === 'signature' && a.dataUrl && !signatureImageCache.has(a.dataUrl)) {
                    const img = new Image();
                    img.src = a.dataUrl;
                    const loadPromise = new Promise((resolve, reject) => {
                        img.onload = () => resolve();
                        img.onerror = (e) => {
                            console.error("Error loading signature image:", e);
                            resolve(); 
                        };
                    });
                    signatureImageCache.set(a.dataUrl, img);
                    imagePromises.push(loadPromise);
                }
            }
        }
        await Promise.all(imagePromises);
    }
    
    // --- NEW: Simplified Text Layer Rendering (Essential for Selection) ---
    async function renderTextLayer(page, viewport, textLayerDiv) {
        const textContent = await page.getTextContent();
        const scaleFactor = 1.5; 
        const normalizedViewport = page.getViewport({ scale: 1.0 });

        textLayerDiv.innerHTML = '';
        
        textContent.items.forEach(item => {
            const htmlDiv = document.createElement('div');
            htmlDiv.textContent = item.str;
            
            const txMatrix = item.transform;
            
            // X position (4th element of transform matrix)
            const finalLeft = txMatrix[4] * scaleFactor; 
            
            // Y position calculation:
            // 1. Convert Y position from PDF (bottom-up) to CSS (top-down)
            // 2. Apply scale factor
            // 3. Subtract item height to get the top edge
            const finalTop = normalizedViewport.height * scaleFactor - (txMatrix[5] * scaleFactor + item.height * scaleFactor);

            htmlDiv.style.left = `${finalLeft}px`;
            htmlDiv.style.top = `${finalTop}px`;
            htmlDiv.style.fontSize = `${item.height * scaleFactor}px`;
            htmlDiv.style.height = `${item.height * scaleFactor}px`;
            htmlDiv.style.width = `${item.width * scaleFactor}px`; 
            htmlDiv.style.color = 'transparent';
            htmlDiv.style.position = 'absolute';
            htmlDiv.style.transformOrigin = '0% 0%';
            
            textLayerDiv.appendChild(htmlDiv);
        });
    }


    // --- RENDER LOGIC: Uses dual canvas structure ---
    async function renderAllPages() {
      if (!pdfDoc) return;
      pdfViewerWrapper.innerHTML = ''; 
      
      await preloadSignatureImages(); 

      const scale = 1.5; 
      const numPages = pdfDoc.numPages;
      pageCountSpan.textContent = numPages;
      
      pageInput.max = numPages;
      pageInput.disabled = false;
      goToPageBtn.disabled = false;

      for (let i = 1; i <= numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale });
        
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'page-wrapper';
        pageWrapper.id = `page-wrapper-${i}`; 
        
        const canvas = document.createElement('canvas'); // Base PDF Canvas
        canvas.className = 'pdfCanvas';
        canvas.dataset.pageNum = i;
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        
        // NEW: Text Layer Div (for selection)
        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.dataset.pageNum = i;
        textLayerDiv.style.width = `${canvas.width}px`; 
        textLayerDiv.style.height = `${canvas.height}px`;

        const annoCanvas = document.createElement('canvas'); // Annotation Canvas (Transparent Overlay)
        annoCanvas.className = 'annoCanvas';
        annoCanvas.dataset.pageNum = i;
        annoCanvas.width = canvas.width;
        annoCanvas.height = canvas.height;
        
        // Set dimensions for the wrapper
        pageWrapper.style.width = `${canvas.width}px`;
        pageWrapper.style.height = `${canvas.height}px`;

        const context = canvas.getContext('2d');
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };
        
        // 1. Render PDF Page
        await page.render(renderContext).promise;
        
        // 2. Render Text Layer for selection
        await renderTextLayer(page, viewport, textLayerDiv);

        // 3. Append elements to the wrapper and viewer
        pageWrapper.appendChild(canvas);
        pageWrapper.appendChild(textLayerDiv);
        pageWrapper.appendChild(annoCanvas);
        pdfViewerWrapper.appendChild(pageWrapper);
        
        // 4. Draw existing annotations on the annotation canvas
        drawAnnotations(annoCanvas, i);
        
        // 5. Add event listeners to annotation canvas
        addPageEventListeners(annoCanvas);
      }
      
      // æ¸²æŸ“å®Œæˆåï¼Œæ ¹æ®å½“å‰å·¥å…·è®¾ç½® pointer-events å’Œ cursor
      updateAnnotationCanvasPointerEvents(currentTool);
    }
	
	async function redrawAllAnnotationLayers() {
        const pageWrappers = document.querySelectorAll('.page-wrapper');
        const redrawPromises = [];
        pageWrappers.forEach(pageWrapper => {
            const annoCanvas = pageWrapper.querySelector('.annoCanvas');
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œé˜²æ­¢æŠ¥é”™
            if (annoCanvas) {
                const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
                redrawPromises.push(redrawAnnotationLayer(annoCanvas, pageNum));
            }
        });
        await Promise.all(redrawPromises);
    }
	
	// --- NEW: Core Undo/Redo Functions ---
    async function undo() {
        // å†å²è®°å½•è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªåˆå§‹çŠ¶æ€ï¼Œæ‰€ä»¥é•¿åº¦å¿…é¡»å¤§äº 1
        if (history.length <= 1) return;

        // 1. å°†å½“å‰çŠ¶æ€ç§»åˆ° Redo å†å²
        const currentState = history.pop(); 
        redoHistory.push(currentState);

        // 2. åº”ç”¨å‰ä¸€ä¸ªçŠ¶æ€
        const previousState = history[history.length - 1]; 
        // ä½¿ç”¨æ·±æ‹·è´å°†çŠ¶æ€åº”ç”¨å› annotations æ•°ç»„
        annotations = JSON.parse(JSON.stringify(previousState)); 
        
        // 3. æ›´æ–°æŒ‰é’®çŠ¶æ€å¹¶é‡ç»˜ç•Œé¢
        updateHistoryButtons();
        await redrawAllAnnotationLayers(); 
        // ç¡®ä¿éšè—ä»»ä½•æ´»åŠ¨çš„ç¼–è¾‘æˆ–æ‹–åŠ¨çŠ¶æ€
        if (activeAnno) await finalizeText();
        hideDragPreview();
    }

    async function redo() {
        if (redoHistory.length === 0) return;

        // 1. å°† Redo çŠ¶æ€ç§»å› History 
        const nextState = redoHistory.pop();
        history.push(nextState);
        
        // 2. åº”ç”¨æ–°çŠ¶æ€
        annotations = JSON.parse(JSON.stringify(nextState)); 
        
        // 3. æ›´æ–°æŒ‰é’®çŠ¶æ€å¹¶é‡ç»˜ç•Œé¢
        updateHistoryButtons();
        await redrawAllAnnotationLayers(); 
        // ç¡®ä¿éšè—ä»»ä½•æ´»åŠ¨çš„ç¼–è¾‘æˆ–æ‹–åŠ¨çŠ¶æ€
        if (activeAnno) await finalizeText();
        hideDragPreview();
    }

    // Function: Only clears and redraws annotations on the annotation canvas
    async function redrawAnnotationLayer(annoCanvas, pageNum) {
        // Clear the annotation canvas
        const ctx = annoCanvas.getContext('2d');
        ctx.clearRect(0, 0, annoCanvas.width, annoCanvas.height);
        drawAnnotations(annoCanvas, pageNum);
    }

    // --- Annotation Drawing (Takes the annotation canvas - omitted for brevity, assume unchanged) ---
    function drawAnnotations(annoCanvas, pageNum) {
        const ctx = annoCanvas.getContext('2d');
        const pageAnnos = annotations[pageNum - 1] || [];

        pageAnnos.forEach(a => {
            // Do NOT draw the active or dragging element on the canvas
            if (dragAnno === a || activeAnno === a) return; 

            ctx.save();
            ctx.globalAlpha = a.type === 'highlight' ? 0.35 : 1.0;
            ctx.fillStyle = a.color;
            ctx.strokeStyle = a.color;

            if (a.type === 'text') {
                ctx.globalAlpha = 1.0;
                ctx.font = `${a.fontSize}px sans-serif`;
                ctx.fillStyle = a.color;
                
                const lines = a.text.split('\n');
                const lineHeight = a.fontSize * 1.2;
                let estimatedWidth = 100;

                lines.forEach((line, index) => {
                    // Y position logic: Draw text baseline at y + fontSize
                    ctx.fillText(line, a.x, a.y + a.fontSize + index * lineHeight);
                    estimatedWidth = Math.max(estimatedWidth, ctx.measureText(line).width);
                });
                
                // Draw dashed border
                ctx.save();
                ctx.strokeStyle = `rgba(${parseInt(a.color.slice(1, 3), 16)}, ${parseInt(a.color.slice(3, 5), 16)}, ${parseInt(a.color.slice(5, 7), 16)}, 0.6)`;
                ctx.setLineDash([4, 4]);
                const textWidth = estimatedWidth + 5;
                const textHeight = lines.length * lineHeight + 5;
                ctx.strokeRect(a.x - 2, a.y - 2, textWidth, textHeight);
                ctx.restore();
                
            } else if (a.type === 'highlight') {
                 // Use fillRect to draw the highlight box
                ctx.fillRect(a.x, a.y, a.w, a.h);
            } else if (a.type === 'signature') {
                const img = signatureImageCache.get(a.dataUrl);
                if (img) {
                    // Note: Signature image is drawn as is (black/transparent). 
                    // a.color is currently not used for the image itself.
                    ctx.drawImage(img, a.x, a.y, a.w, a.h);
                }
            }

            ctx.restore();
        });
    }


    // --- Interaction Logic (Mouse/Touch Handlers) ---
    function isInsideAnnotation(point, anno, canvas) {
        if (anno.type === 'highlight') {
            const minX = Math.min(anno.x, anno.x + anno.w);
            const maxX = Math.max(anno.x, anno.x + anno.w);
            const minY = Math.min(anno.y, anno.y + anno.h);
            const maxY = Math.max(anno.y, anno.y + anno.h);
            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
        } else if (anno.type === 'text') {
            const lines = anno.text.split('\n');
            const lineHeight = anno.fontSize * 1.2;
            let maxWidth = 0;
            const ctx = canvas.getContext('2d');
            ctx.font = `${anno.fontSize}px sans-serif`;
            lines.forEach(line => {
                maxWidth = Math.max(maxWidth, ctx.measureText(line).width);
            });
            
            // NEW: ç¡®ä¿æœ€å°ç‚¹å‡»åŒºåŸŸï¼Œä»¥æ–¹ä¾¿ç§»åŠ¨ç«¯æ‰‹æŒ‡æ“ä½œ
            const minW = 50; 
            const minH = anno.fontSize * 1.2; 

            // Text bounding box: x, y (top) to x + width, y + height
            const textWidth = Math.max(maxWidth + 5, minW); // å®½åº¦è‡³å°‘ä¸º 50px
            const textHeight = Math.max(lines.length * lineHeight + 5, minH); // é«˜åº¦è‡³å°‘ä¸ºä¸€è¡Œæ–‡æœ¬é«˜åº¦

            return point.x >= anno.x && point.x <= anno.x + textWidth && 
                   point.y >= anno.y && point.y <= anno.y + textHeight;

        } else if (anno.type === 'signature') {
             return point.x >= anno.x && point.x <= anno.x + anno.w && 
                    point.y >= anno.y && point.y <= anno.y + anno.h;
        }
        return false;
    }

    function getCanvasPos(evt, canvas) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else {
            clientX = evt.clientX;
            clientY = evt.clientY;
        }
        
        return { 
            x: (clientX - rect.left) * (canvas.width / rect.width), 
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    }
    
    function setupDragPreview(anno, annoCanvas) {
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;
        
        if (anno.type === 'text') {
            const fontSize = anno.fontSize;
            const lineHeight = fontSize * 1.2;
            
            pageWrapper.appendChild(dragPreview);
            dragPreview.textContent = anno.text;
            dragPreview.style.cssText = `
                display: block;
                position: absolute;
                left: ${anno.x * scaleFactor}px;
                top: ${anno.y * scaleFactor}px;
                color: ${anno.color};
                font-size: ${fontSize}px;
                font-family: sans-serif;
                border: 1px solid ${anno.color};
                min-width: 50px; 
                min-height: ${lineHeight}px; 
                line-height: ${lineHeight}px;
                padding-right: 2px;
                width: fit-content;
                height: fit-content;
                white-space: pre-wrap;
                z-index: 99;
                background: rgba(255, 255, 255, 0.8);
                opacity: 0.8;
            `;
            
        } else if (anno.type === 'signature') {
            const img = signatureImageCache.get(anno.dataUrl);
            if (img) {
                 pageWrapper.appendChild(dragPreview);
                 dragPreview.innerHTML = '';
                 dragPreview.style.cssText = `
                    display: block;
                    position: absolute;
                    left: ${anno.x * scaleFactor}px;
                    top: ${anno.y * scaleFactor}px;
                    width: ${anno.w * scaleFactor}px;
                    height: ${anno.h * scaleFactor}px;
                    border: 1px dashed #000;
                    background-image: url('${anno.dataUrl}');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    z-index: 99;
                    opacity: 0.8;
                 `;
            }
        }
    }

    function hideDragPreview() {
        dragPreview.style.display = 'none';
        dragPreview.innerHTML = '';
        dragPreview.style.backgroundImage = 'none';
    }


    async function handleMouseDown(e, annoCanvas, pageNum) {
        if (e.button === 2) return; // Ignore right-click
        if (currentTool === 'select_text' || currentTool === 'highlight') {
            // Let the text layer handle selection
            return; 
        }

        if (activeAnno) {
            await finalizeText();
        }

        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;
        
        // --- SIGNATURE PLACEMENT ACTIVATION LOGIC (FIXED) ---
        if (currentTool === 'signature') {
            // Not clicking on an existing annotation, open the signature pad and store the position
            signaturePlacementPos = pos;
            signaturePlacementPageNum = pageNum;
            openSignaturePad();
            return; // Prevent subsequent logic in handleMouseDown
        }
        // --- END SIGNATURE PLACEMENT ACTIVATION LOGIC ---

        let pageAnnos = annotations[pageNum - 1] || [];
        const clickedAnno = pageAnnos.find(a => (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas) );

        // --- DRAGGING (MOVE) LOGIC ---
        if ((currentTool === 'mouse' || currentTool === 'text') && clickedAnno) {
            saveState();
            dragAnno = clickedAnno;
            dragOffset = {x: pos.x - clickedAnno.x, y: pos.y - clickedAnno.y};
            setupDragPreview(dragAnno, annoCanvas);
            await redrawAnnotationLayer(annoCanvas, pageNum);
            isDragging = true;
			// **å…³é”®ä¿®å¤ç‚¹ 1: åœ¨å¼€å§‹æ‹–åŠ¨æ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º (é˜²æ­¢æ»šåŠ¨)**
			if (e.touches) {
				e.preventDefault();
			}
            return;
        }

        // --- DELETE Tool Logic ---
        if (currentTool === 'delete') {
            const annoToDelete = pageAnnos.find(a => isInsideAnnotation(pos, a, annoCanvas));
            if (annoToDelete) {
                saveState();
                annotations[pageNum - 1] = pageAnnos.filter(a => a !== annoToDelete);
                await redrawAnnotationLayer(annoCanvas, pageNum);
            }
            dragStart = null;
            return;
        }
        
        // --- CREATION LOGIC (Only Text remains here) ---
        if (currentTool === 'text' && !clickedAnno && !activeAnno) {
            const fontSize = parseInt(fontSizeSelect.value, 10);
            const newAnno = {
                type: 'text',
                x: pos.x,
                y: pos.y,
                color: colorInput.value,
                text: 'New Text',
                fontSize: fontSize,
            };
            saveState();
            annotations[pageNum - 1].push(newAnno);
            await activateTextEdit(newAnno, pageNum, annoCanvas);
            dragStart = null;
            return;
        }

        dragStart = null;
        dragEnd = null;
    }

    // Handles dragging/hover
    function handleMouseMove(e, annoCanvas, pageNum) {
        // å¦‚æœæ˜¯æ–‡å­—é€‰æ‹©æˆ–é«˜äº®å·¥å…·ï¼Œç›´æ¥è¿”å›
        if (currentTool === 'select_text' || currentTool === 'highlight') return;
        
        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;

        // 1. Dragging Annotation
        if (isDragging && dragAnno) {
            const rect = annoCanvas.getBoundingClientRect();
            const scaleFactor = rect.width / annoCanvas.width;
            
            dragAnno.x = pos.x - dragOffset.x;
            dragAnno.y = pos.y - dragOffset.y;
            
            // Update drag preview position
            dragPreview.style.left = `${dragAnno.x * scaleFactor}px`;
            dragPreview.style.top = `${dragAnno.y * scaleFactor}px`;
			
			<!-- e.preventDefault(); -->
			
            return;
        }
        
        // 2. Cursor/Hover feedback (only for mouse/delete tool)
        if (currentTool === 'mouse' || currentTool === 'delete') {
            const pageAnnos = annotations[pageNum - 1] || [];
            const hoveredAnno = pageAnnos.find(a => (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas) );
            
            if (hoveredAnno) {
                annoCanvas.style.cursor = currentTool === 'delete' ? 'crosshair' : 'move';
            } else if (currentTool === 'signature') {
                 annoCanvas.style.cursor = 'crosshair';
            } else {
                annoCanvas.style.cursor = 'default';
            }
        }
    }


    async function handleMouseUp(e, annoCanvas, pageNum) {
        // å¦‚æœæ˜¯æ–‡å­—é€‰æ‹©æˆ–é«˜äº®å·¥å…·ï¼Œç›´æ¥è¿”å›
        if (currentTool === 'select_text' || currentTool === 'highlight') return;

        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;

        // 1. End Annotation Dragging
        if (dragAnno) {
            if (dragAnno.type === 'text' || dragAnno.type === 'signature') {
                hideDragPreview();
            }
            dragAnno = null;
            dragOffset = {x: 0, y: 0};
            isDragging = false;
            await redrawAnnotationLayer(annoCanvas, pageNum);
            return;
        }

        // 2. Old highlight drawing logic removed, no need to check dragStart/dragEnd here.
    }


    // --- NEW: Handle Text Selection for Highlighting ---
    pdfViewerWrapper.addEventListener('mouseup', handleSelectionHighlight);
    pdfViewerWrapper.addEventListener('touchend', handleSelectionHighlight, { passive: true });
    async function handleSelectionHighlight(e) {
        if (currentTool !== 'highlight') return;
        
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);

        // æ£€æŸ¥é€‰æ‹©æ˜¯å¦åœ¨ PDF å®¹å™¨å†…çš„ textLayer ä¸­
        let parentElement = range.commonAncestorContainer.parentElement;
        while(parentElement && !parentElement.classList.contains('textLayer')) {
            parentElement = parentElement.parentElement;
        }
        
        if (!parentElement) { 
            // é€‰æ‹©ä¸åœ¨ text layer ä¸­
            selection.removeAllRanges();
            return;
        }
        
        const pageWrapper = parentElement.closest('.page-wrapper');
        const pageNum = parseInt(pageWrapper.id.split('-')[2], 10);
        const annoCanvas = pageWrapper.querySelector('.annoCanvas');
        if (!annoCanvas) return;
        
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactorX = annoCanvas.width / rect.width;
        const scaleFactorY = annoCanvas.height / rect.height;
        
        const selectionRects = range.getClientRects();
        
        if (selectionRects.length > 0) {
            saveState(); // åœ¨æ·»åŠ æ–°æ³¨é‡Šä¹‹å‰ä¿å­˜çŠ¶æ€
        }
        
        let newAnnos = [];
        const color = colorInput.value;
        
        Array.from(selectionRects).forEach(r => {
            // åæ ‡ä»å±å¹•ï¼ˆç›¸å¯¹äºè§†å£ï¼‰è½¬æ¢ä¸º Canvas åæ ‡ (ç›¸å¯¹äºé¡µé¢çš„ Annotation Canvas)
            const x = (r.left - rect.left) * scaleFactorX;
            const y = (r.top - rect.top) * scaleFactorY;
            const w = r.width * scaleFactorX;
            const h = r.height * scaleFactorY;

            // è¿‡æ»¤æ‰å¤ªå°çš„ï¼ˆä¾‹å¦‚ï¼Œå•ä¸ªç©ºæ ¼ï¼‰
            if (w > 2 && h > 2) { 
                 newAnnos.push({
                    type: 'highlight',
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    color: color,
                });
            }
        });
        
        if (newAnnos.length > 0) {
            // å°†æ–°çš„ highlight annotations æ·»åŠ åˆ°å¯¹åº”çš„é¡µé¢
            annotations[pageNum - 1].push(...newAnnos);
            await redrawAnnotationLayer(annoCanvas, pageNum);
        }
        
        // æ¸…é™¤æ–‡æœ¬é€‰æ‹©
        selection.removeAllRanges();
    }


    // Handle text annotation double-click for editing
    pdfViewerWrapper.addEventListener('dblclick', handleDoubleClick);
    async function handleDoubleClick(e) {
        // Only run for text tool
        if (currentTool !== 'text') return;
        
        let target = e.target;
        // Find the annotation canvas that was double-clicked
        while(target && !target.classList.contains('annoCanvas')) {
            target = target.parentNode;
        }
        
        if (!target) return;
        
        const annoCanvas = target;
        const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
        const pos = getCanvasPos(e, annoCanvas);
        
        const pageAnnos = annotations[pageNum - 1] || [];
        const clickedAnno = pageAnnos.find(a => a.type === 'text' && isInsideAnnotation(pos, a, annoCanvas) );
        
        if (clickedAnno) {
            await activateTextEdit(clickedAnno, pageNum, annoCanvas);
        }
    }
    
    // --- Annotation Text Finalization (omitted for brevity, assume unchanged) ---
    async function finalizeText() {
        if (!activeAnno) return;
        
        const newText = annotationInput.value;
        const canvasToRedraw = activeAnnoCanvas;
        const pageNum = activeAnnoPage;
        
        annotationInput.style.display = 'none';
        
        if (newText.trim() === '') {
            annotations[pageNum - 1] = annotations[pageNum - 1].filter(a => a !== activeAnno);
        } else {
            activeAnno.text = newText;
        }
        
        activeAnno = null;
        activeAnnoPage = -1;
        activeAnnoCanvas = null;
        activePageWrapper = null;
        
        if (canvasToRedraw) {
            await redrawAnnotationLayer(canvasToRedraw, pageNum);
        }
		
		setTool(toolMouseBtn, 'mouse');
    }

    async function activateTextEdit(anno, pageNum, annoCanvas) {
        if (activeAnno) {
            await finalizeText();
        }
        
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;
        const fontSize = anno.fontSize;
        const lineHeight = fontSize * 1.2;

        pageWrapper.appendChild(annotationInput);

        const left = (anno.x * scaleFactor);
        const top = (anno.y * scaleFactor);
        
        annotationInput.value = anno.text;
        
        annotationInput.style.cssText = `
            display: block;
            position: absolute;
            left: ${left}px;
            top: ${top}px;
            color: ${anno.color};
            font-size: ${fontSize}px;
            font-family: sans-serif;
            border: 1px dashed ${anno.color};
            min-width: 50px;
            min-height: ${lineHeight}px;
            line-height: ${lineHeight}px;
            padding-right: 2px;
            width: fit-content;
            height: fit-content;
            white-space: pre-wrap;
            z-index: 100;
        `;
        
        activeAnno = anno;
        activeAnnoPage = pageNum;
        activeAnnoCanvas = annoCanvas;
        activePageWrapper = pageWrapper;
        
        // å…³é”®: å°†å·¥å…·æ çš„é¢œè‰²å’Œå¤§å°è®¾ç½®ä¸ºå½“å‰ç¼–è¾‘æ³¨é‡Šçš„å€¼
        colorInput.value = anno.color;
        fontSizeSelect.value = anno.fontSize.toString();

        await redrawAnnotationLayer(annoCanvas, pageNum); // Redraw to hide the old visual
        
        window.requestAnimationFrame(() => {
            annotationInput.focus();
            annotationInput.select();
        });
    }


    // --- Signature Modal and Logic ---
    function openSignaturePad() {
        if (!signaturePlacementPos) return; 
        setupSignaturePad();
        signatureModal.style.display = 'block';
    }

    function closeSignaturePad() {
        signatureModal.style.display = 'none';
        signaturePlacementPos = null;
        signaturePlacementPageNum = -1;
    }
    
    closeSignatureBtn.onclick = closeSignaturePad;
    clearSignatureBtn.onclick = setupSignaturePad;
    saveSignatureBtn.onclick = () => {
        saveAndPlaceSignature();
    };

    function setupSignaturePad() {
        signaturePadCanvas.width = 560;
        signaturePadCanvas.height = 200;
        signatureCtx.clearRect(0, 0, signaturePadCanvas.width, signaturePadCanvas.height);
        isDrawing = false;
        // --- ä¿®å¤ 2: ä½¿ç”¨å½“å‰é¢œè‰²é€‰æ‹©å™¨çš„å€¼ä½œä¸ºç­¾åç¬”è§¦é¢œè‰² ---
        signatureCtx.strokeStyle = colorInput.value; 
        // --- ä¿®å¤ 2 ç»“æŸ ---
        // FIX: ä½¿ç”¨ fontSizeSelect çš„å€¼ä½œä¸ºç­¾åç²—ç»†ï¼Œå¹¶è¿›è¡Œç¼©æ”¾ (ä¾‹å¦‚ï¼š12px -> 3px, 24px -> 6px)
        signatureCtx.lineWidth = parseInt(fontSizeSelect.value, 10) / 4; 
        signatureCtx.lineCap = 'round';
    }

    function draw(e) {
        if (!isDrawing) return;
        signatureCtx.beginPath();
        signatureCtx.moveTo(lastX, lastY);
        signatureCtx.lineTo(e._x, e._y);
        signatureCtx.stroke();
        [lastX, lastY] = [e._x, e._y];
    }
    
    function handleSignatureMove(e) {
        if (!isDrawing) return;
        const rect = signaturePadCanvas.getBoundingClientRect();
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        e._x = (clientX - rect.left) * scaleX;
        e._y = (clientY - rect.top) * scaleY;
        draw(e);
    }
    
    function handleSignatureStart(e) {
        isDrawing = true;
        const rect = signaturePadCanvas.getBoundingClientRect();
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        e._x = (clientX - rect.left) * scaleX;
        e._y = (clientY - rect.top) * scaleY;

        [lastX, lastY] = [e._x, e._y];
        draw(e);
    }

    function handleSignatureEnd() {
        if (isDrawing) {
            isDrawing = false;
        }
    }

    signaturePadCanvas.addEventListener('mousedown', handleSignatureStart);
    signaturePadCanvas.addEventListener('mousemove', handleSignatureMove);
    signaturePadCanvas.addEventListener('mouseup', handleSignatureEnd);
    signaturePadCanvas.addEventListener('mouseout', handleSignatureEnd);
    signaturePadCanvas.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        handleSignatureStart(e); 
    }, { passive: false });
    signaturePadCanvas.addEventListener('touchmove', (e) => { 
        e.preventDefault(); 
        handleSignatureMove(e); 
    }, { passive: false });
    signaturePadCanvas.addEventListener('touchend', handleSignatureEnd);

    async function saveAndPlaceSignature() {
        if (!signaturePlacementPos || signaturePlacementPageNum === -1) {
            alert("Signature placement position is missing.");
            return;
        }
        
        const dataUrl = signaturePadCanvas.toDataURL('image/png');
        const pageNum = signaturePlacementPageNum;
        const annoCanvas = document.querySelector(`#page-wrapper-${pageNum} .annoCanvas`);

        if (!annoCanvas) {
            console.error("Could not find annotation canvas for page", pageNum);
            return;
        }

        // Check if the signature pad is empty (white background)
        const isEmpty = isCanvasEmpty(signaturePadCanvas, signatureCtx);
        if (isEmpty) {
            alert("The signature pad is empty. Please draw your signature.");
            return;
        }
        
        // Define size for the signature annotation. Using a fixed ratio/size.
        const width = 150; 
        const height = 60;
        
        const newAnno = {
            type: 'signature',
            x: signaturePlacementPos.x - width / 2, // Center the signature on the click point
            y: signaturePlacementPos.y - height / 2,
            w: width,
            h: height,
            color: colorInput.value, // Color of the drawn image is black, but keep this for consistency
            dataUrl: dataUrl,
        };
        
        saveState();
        annotations[pageNum - 1].push(newAnno);
        
        // Cache the image object for drawing on canvas
        const img = new Image();
        img.src = dataUrl;
        signatureImageCache.set(dataUrl, img);
        await new Promise(resolve => {
            img.onload = resolve;
            img.onerror = resolve; // Continue even if load fails
        });
        
        signatureModal.style.display = 'none';
        await redrawAnnotationLayer(annoCanvas, pageNum);

        signaturePlacementPos = null;
        signaturePlacementPageNum = -1;
        setTool(toolMouseBtn, 'mouse'); // Switch to mouse tool after placement
    }

    function isCanvasEmpty(canvas, ctx) {
        const pixelBuffer = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
        // Check if all pixels are white (or transparent if it was initialized clear)
        // Since we draw a signature on a white background, we look for non-white pixels.
        // A simple check is to look for pixels that are not a certain color, but for simplicity
        // we can check if the canvas contains non-zero data.
        return !pixelBuffer.some(color => color !== 0xFFFFFFFF && color !== 0x00000000); 
    }

    // --- Core PDF Functions ---
    async function openPdfFromFile(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            pdfDoc = await loadingTask.promise;
            originalFile = file; // FIX: å­˜å‚¨åŸå§‹æ–‡ä»¶å¯¹è±¡åˆ°å…¨å±€å˜é‡
            annotations = Array.from({ length: pdfDoc.numPages }, () => []);
            signatureImageCache.clear();
            history = [];
            redoHistory = [];
            saveState();
            await renderAllPages();
            
            // ç¡®ä¿åœ¨æ¸²æŸ“å®Œæˆåï¼Œåº”ç”¨å½“å‰å·¥å…·çš„ pointer-events å’Œ cursor è®¾ç½®
            updateAnnotationCanvasPointerEvents(currentTool);
            downloadBtn.disabled = false;
        } catch (error) {
            console.error("PDF Loading Error:", error);
            alert("Error loading PDF. Please check the browser console (F12) for details.");
            pdfViewerWrapper.innerHTML = 'PDF loading failed.';
            pdfDoc = null;
            downloadBtn.disabled = true;
        }
    }

    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        await openPdfFromFile(file);
    });

    function addPageEventListeners(annoCanvas) {
        const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
        const asyncHandler = (fn) => (e) => {
            // å…³é”®ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯è§¦æ‘¸äº‹ä»¶ï¼Œå¹¶ä¸”å·¥å…·æ˜¯'select_text'æˆ–'highlight'
            // å¦‚æœæ˜¯ï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ»šåŠ¨è¦†ç›–é€‰æ‹©
            if (e.touches && (currentTool === 'highlight' || currentTool === 'mouse') && isDragging) {
                e.preventDefault();
            }
            fn(e, annoCanvas, pageNum).catch(console.error);
        };

        // ä¸“é—¨å¤„ç† touchmoveï¼Œå› ä¸º handleMouseMove å†…éƒ¨çš„ preventDefault ä»…åœ¨ isDragging æ—¶è§¦å‘
        const touchMoveHandler = (e) => {
            // ä»…åœ¨æ‹–æ‹½ç§»åŠ¨æ³¨é‡Šæ—¶é˜»æ­¢é»˜è®¤æ»šåŠ¨ï¼›å¦åˆ™è®©æµè§ˆå™¨åŸç”Ÿæ–‡æœ¬é€‰æ‹©ç”Ÿæ•ˆ
            if (isDragging) {
                e.preventDefault();
            }
            handleMouseMove(e, annoCanvas, pageNum);
        };
        
        // Mouse events
        annoCanvas.addEventListener('mousedown', asyncHandler(handleMouseDown));
        annoCanvas.addEventListener('mousemove', (e) => handleMouseMove(e, annoCanvas, pageNum));
        annoCanvas.addEventListener('mouseup', asyncHandler(handleMouseUp));
        
        // Touch events: 
        // 1. touchstart ä½¿ç”¨ asyncHandlerï¼Œå¹¶åœ¨å…¶å†…éƒ¨é˜»æ­¢é»˜è®¤è¡Œä¸º (å·²åœ¨ asyncHandler ä¸­ä¿®å¤)
        annoCanvas.addEventListener('touchstart', asyncHandler(handleMouseDown), { passive: false });
        // 2. touchmove ä½¿ç”¨ touchMoveHandlerï¼Œåœ¨å…¶å†…éƒ¨é˜»æ­¢é»˜è®¤è¡Œä¸º
        annoCanvas.addEventListener('touchmove', touchMoveHandler, { passive: false });
        annoCanvas.addEventListener('touchend', asyncHandler(handleMouseUp));
    }
    
    function goToPage(pageNum) {
        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            pageWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
            pageInput.value = pageNum;
        }
    }
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (pdfDoc) {
            let currentPage = parseInt(pageInput.value, 10);
            let newPage = currentPage;
            
            if (e.key === 'ArrowRight' || e.key === 'PageDown') {
                newPage = Math.min(pdfDoc.numPages, currentPage + 1);
            } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                newPage = Math.max(1, currentPage - 1);
            } else {
                return;
            }
            
            if (newPage !== currentPage) {
                 e.preventDefault(); 
                 goToPage(newPage);
            }
        }
    });

    // Handle jump to page button click
    goToPageBtn.onclick = () => {
        const pageNum = parseInt(pageInput.value, 10);
        if (pdfDoc && pageNum >= 1 && pageNum <= pdfDoc.numPages) {
            goToPage(pageNum);
        } else {
            alert(`Please enter a valid page number between 1 and ${pdfDoc.numPages}`);
            pageInput.value = 1;
        }
    };
	
	// --- å†å²æ“ä½œæŒ‰é’®äº‹ä»¶ç»‘å®š (è¯·å°†æ­¤æ®µä»£ç æ·»åŠ åˆ°è¿™é‡Œ) ---
    undoBtn.onclick = () => { 
        undo().catch(console.error); 
    };
    redoBtn.onclick = () => { 
        redo().catch(console.error); 
    };


    
    // --- Helpers for robust color + rendering (added) ---
    function parseColorToRgb01(c) {
        // Returns [r,g,b] in 0..1, defaults to black
        if (!c || typeof c !== 'string') return [0,0,0];
        const s = c.trim();
        // #RRGGBB
        if (/^#([0-9a-fA-F]{6})$/.test(s)) {
            const r = parseInt(s.slice(1,3),16)/255;
            const g = parseInt(s.slice(3,5),16)/255;
            const b = parseInt(s.slice(5,7),16)/255;
            return [r,g,b];
        }
        // rgb/rgba
        const m = s.match(/^rgba?\(([^)]+)\)$/i);
        if (m) {
            const parts = m[1].split(',').map(x=>x.trim());
            const r = Math.max(0, Math.min(255, parseFloat(parts[0])))/255;
            const g = Math.max(0, Math.min(255, parseFloat(parts[1])))/255;
            const b = Math.max(0, Math.min(255, parseFloat(parts[2])))/255;
            return [r,g,b];
        }
        return [0,0,0];
    }

    function hasNonAscii(str) {
        // Treat anything beyond basic ASCII as needing image rendering to avoid PDF font encoding issues
        return /[^\x00-\x7F]/.test(str || "");
    }

    function makeTextPngDataUrl(text, fontPx, colorCss, maxWidthPx) {
        // Render text into a tight PNG via an offscreen canvas; supports CJK using system fonts.
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans CJK SC', 'Noto Sans SC', 'Microsoft YaHei', 'PingFang SC', sans-serif";
        ctx.font = `${fontPx}px ${fontFamily}`;
        ctx.textBaseline = 'top';
        const lines = (text ?? "").split('\n');

        // measure
        let maxW = 0;
        let totalH = 0;
        const lineH = fontPx * 1.2;
        for (const line of lines) {
            const w = Math.ceil(ctx.measureText(line).width);
            maxW = Math.max(maxW, w);
            totalH += lineH;
        }
        maxW = Math.max(1, Math.min(maxW, maxWidthPx || maxW));
        totalH = Math.max(1, Math.ceil(totalH));

        canvas.width = maxW;
        canvas.height = totalH;

        // re-apply font after resize
        ctx.font = `${fontPx}px ${fontFamily}`;
        ctx.textBaseline = 'top';
        ctx.fillStyle = colorCss || '#000000';
        ctx.clearRect(0,0,canvas.width,canvas.height);

        let y = 0;
        for (const line of lines) {
            ctx.fillText(line, 0, y);
            y += lineH;
        }
        return canvas.toDataURL('image/png');
    }


    // --- Download PDF Logic (FIXED) ---
    downloadBtn.onclick = async () => {
        if (!pdfDoc) {
            alert('Please upload a PDF first.');
            return;
        }
        if (activeAnno) {
            await finalizeText();
        }
        
        downloadBtn.disabled = true;
        downloadBtn.textContent = 'Generating...';

        try {
            if (!originalFile) {
                throw new Error("Original PDF file reference is missing.");
            }
            const originalPdfBytes = await originalFile.arrayBuffer();
            const pdf = await pdfLib.PDFDocument.load(originalPdfBytes);
            const pages = pdf.getPages();
            // ç¡®ä¿åµŒå…¥å­—ä½“æˆåŠŸï¼Œå¦åˆ™åç»­ drawText ä¼šå¤±è´¥
            const font = await pdf.embedFont(pdfLib.StandardFonts.Helvetica);

            // æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤å…¨å±€ç¼©æ”¾è®¡ç®—ï¼Œæ”¹ä¸ºåœ¨å¾ªç¯å†…é’ˆå¯¹æ¯ä¸€é¡µè¿›è¡Œç²¾ç¡®è®¡ç®—
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const pageAnnos = annotations[i] || [];
                const pageHeight = page.getHeight();
                
                // 1. è·å–å½“å‰é¡µçš„ Canvas å…ƒç´ 
                const currentPageCanvas = document.querySelector(`#page-wrapper-${i + 1} .pdfCanvas`);
                if (!currentPageCanvas) {
                    console.error(`Canvas for page ${i + 1} not found, skipping annotations for this page.`);
                    continue; 
                }
                
                // 2. è®¡ç®— Canvas åƒç´  åˆ° PDF ç‚¹ çš„ç²¾ç¡®ç¼©æ”¾å› å­
                // scaleX = PDF_Width_in_Points / Canvas_Width_in_Pixels
                const scaleX = page.getWidth() / currentPageCanvas.width;
                const scaleY = page.getHeight() / currentPageCanvas.height;
                
                const signatureEmbedPromises = [];

                pageAnnos.forEach(a => {
                    if (a.type === 'text') {
                        const lines = a.text.split('\n');
                        const lineHeight = a.fontSize * 1.2;
                        
                        lines.forEach((line, index) => {
                            // Canvas (top-left) to PDF (bottom-left) coordinates
                            const x = a.x * scaleX;
                            // yTopCanvas æ˜¯ Canvas ä¸Šçš„æ–‡æœ¬åŸºçº¿ä½ç½® (ç›¸å¯¹äºé¡¶éƒ¨)
                            const yTopCanvas = a.y + a.fontSize + index * lineHeight; 
                            // y æ˜¯ PDF ä¸Šçš„æ–‡æœ¬åŸºçº¿ä½ç½® (ç›¸å¯¹äºåº•éƒ¨)
                            const y = pageHeight - (yTopCanvas * scaleY);

                            const [r01, g01, b01] = parseColorToRgb01(a.color);

                            if (hasNonAscii(line)) {
                                // Workaround: render non-ASCII text (e.g., Chinese) as an image to avoid PDF font encoding failures.
                                signatureEmbedPromises.push(async () => {
                                    const dataUrl = makeTextPngDataUrl(line, a.fontSize, a.color, currentPageCanvas.width);
                                    const pngImage = await pdf.embedPng(dataUrl);

                                    const imgW = pngImage.width * scaleX;
                                    const imgH = pngImage.height * scaleY;

                                    const yTopTextCanvas = a.y + index * lineHeight; // top of this line in canvas coords
                                    const yImg = pageHeight - ((yTopTextCanvas + pngImage.height) * scaleY);

                                    page.drawImage(pngImage, {
                                        x: x,
                                        y: yImg,
                                        width: imgW,
                                        height: imgH,
                                        opacity: 1.0,
                                    });
                                });
                            } else {
                                page.drawText(line, {
                                    x: x,
                                    y: y,
                                    font: font,
                                    size: a.fontSize * scaleX, // å­—ä½“å¤§å°ä¹Ÿéœ€è¦ç¼©æ”¾
                                    color: pdfLib.rgb(r01, g01, b01),
                                });
                            }
                        });
                    } else if (a.type === 'highlight') {
                        const [r, g, b] = parseColorToRgb01(a.color);

                        const x = a.x * scaleX;
                        const yTopCanvas = a.y; // çŸ©å½¢é¡¶éƒ¨
                        const y = pageHeight - ((yTopCanvas + a.h) * scaleY); // PDF åº•éƒ¨åæ ‡
                        const w = a.w * scaleX;
                        const h = a.h * scaleY;

                        page.drawRectangle({
                            x: x,
                            y: y,
                            width: w,
                            height: h,
                            color: pdfLib.rgb(r, g, b),
                            opacity: 0.35,
                            borderWidth: 0
                        });
                    } else if (a.type === 'signature') {
                        signatureEmbedPromises.push(async () => {
                            const pngImage = await pdf.embedPng(a.dataUrl); 
                            
                            const x = a.x * scaleX;
                            const yTopCanvas = a.y; 
                            const y = pageHeight - ((yTopCanvas + a.h) * scaleY); // PDF åº•éƒ¨åæ ‡
                            const w = a.w * scaleX;
                            const h = a.h * scaleY;

                            page.drawImage(pngImage, {
                                x: x, 
                                y: y, 
                                width: w, 
                                height: h,
                                opacity: 1.0, 
                            });
                        });
                    }
                });

                await Promise.all(signatureEmbedPromises.map(p => p()));
            }

            const pdfBytes = await pdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const name = (originalFile && originalFile.name) ? originalFile.name.replace(/\.pdf$/i, '') : 'document';
            a.download = `${name}-annotated.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

        } catch (error) {
            console.error("PDF Download Error:", error);
            alert("Error generating annotated PDF. Please check the browser console (F12) for details.");
        } finally {
            downloadBtn.textContent = 'â¬‡ï¸';
            downloadBtn.disabled = false;
        }
    };
  </script>
</body>
</html>