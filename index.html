<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Upload, Inline Annotation & Download</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
	  /* NEW: Top Bar Notification Styles (Modified for Bootstrap-like Alert) */
	#topNotification {
		position: fixed;
		top: 20px; /* è·ç¦»é¡¶éƒ¨ç•™å‡ºç©ºé—´ */
		left: 50%; /* å±…ä¸­ */
		transform: translateX(-50%); /* å±…ä¸­ */
		width: auto; /* è‡ªåŠ¨å®½åº¦ */
		max-width: 90%; /* æœ€å¤§å®½åº¦é™åˆ¶ */
		min-width: 300px; /* æœ€å°å®½åº¦ */
		text-align: center;
		padding: 10px 20px; /* è°ƒæ•´å†…è¾¹è· */
		color: white;
		font-size: 16px;
		z-index: 10000;
        
		border-radius: 8px; /* æŸ”å’Œçš„åœ†è§’ */
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* æŸ”å’Œçš„é˜´å½± */
		
		/* æ¸å˜æ•ˆæœçš„è¿‡æ¸¡è®¾ç½®ï¼šé€æ˜åº¦ï¼ˆæ¸å˜æ¶ˆå¤±ï¼‰å’Œä½ç½®ï¼ˆå±…ä¸­åŠ¨ç”»ï¼‰*/
		opacity: 0; /* é»˜è®¤éšè— (é€æ˜) */
		transition: opacity 0.4s ease-out, transform 0.3s ease-out; 
        pointer-events: none; /* é»˜è®¤ä¸æ‹¦æˆªç‚¹å‡»äº‹ä»¶ */
	}
    /* æ§åˆ¶æ˜¾ç¤ºçš„ç±»ï¼Œå®ç°æ¸å˜æ•ˆæœ */
    .notification-show {
        opacity: 1 !important;
        pointer-events: auto !important; /* æ˜¾ç¤ºæ—¶å…è®¸ç‚¹å‡» */
    }

	/* æŸ”å’Œçš„æˆåŠŸé¢œè‰² (Success: Bootstrap Green) */
	.notification-success {
		background-color: #28a745;
		color: #ffffff;
	}
	/* æŸ”å’Œçš„å¤±è´¥é¢œè‰² (Danger: Bootstrap Red) */
	.notification-failure {
		background-color: #dc3545; 
		color: #ffffff;
		cursor: pointer; 
	}
    /* ---------------------------------------------------- */
    
    body { 
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
        margin: 16px auto; 
        max-width: 1000px; 
    }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:flex-start; margin-bottom:12px; } 
    .page-controls { display:flex; gap:8px; align-items:center; }
    .page-container { border:1px solid #ddd; margin-bottom: 10px; } 
    .tools { display:flex; gap:8px; align-items:center; }
    .label { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    .row { margin:8px 0; }
    
    /* 1. æŒ‰é’®åŸºç¡€æ ·å¼ */
    button, input, select { 
        padding:6px 10px; 
        font-size:14px; 
    }
    
    /* é‡ç‚¹ä¿®æ”¹ï¼šç»Ÿä¸€å·¥å…·æŒ‰é’®å°ºå¯¸å’Œæ ·å¼ */
    .tools button, .page-controls button { 
        width: 40px; /* Consistent width */
        height: 40px; /* Consistent height */
        padding: 0; /* Remove padding for better icon centering */
        font-size: 20px; /* Larger size for icons */
        line-height: 40px; /* Center vertical */
        flex-grow: 0; /* Prevent buttons from growing */
        text-align: center; 
        box-sizing: border-box; /* Include border/padding in size */
    }
    
    .tool-active { background:#1f6feb; color:white; }
    
    /* é’ˆå¯¹ç‰¹æ®Šæ§ä»¶è¿›è¡Œå°ºå¯¸è°ƒæ•´ */
    .tools input[type="color"] { width: 40px; height: 40px; padding: 2px; flex-grow: 0; }
    #fontSize { 
        width: 60px; 
        height: 40px; 
        padding: 0 4px; 
        line-height: normal; /* Override line-height for select */
        font-size: 14px; 
        flex-grow: 0;
    } 
    /* ä¸‹è½½æŒ‰é’®å¯ä»¥ç•¥å¾®å¤§ä¸€ç‚¹ */
    #downloadBtn { 
        width: auto; 
        min-width: 40px; 
        padding: 0 10px; 
        font-size: 16px; 
        line-height: normal; 
        height: 40px; 
    } 

    #pdf-viewer-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center; 
        width: 100%;
        cursor: default; 
    }
    
    .page-wrapper {
        position: relative; 
        display: inline-block; 
        margin-bottom: 10px; 
        box-shadow: 0 0 5px rgba(0,0,0,0.1);
        cursor: default; 
    }
    
    .pdfCanvas, .annoCanvas {
        display: block;
    }

    /* Annotation Canvas Overlay */
    .annoCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 5; 
        pointer-events: auto; 
    }

    /* Text Layer æ ·å¼ */
    .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        z-index: 2; 
        line-height: 1.0;
        color: transparent; 
        user-select: text; 
        -webkit-user-select: text;
        -webkit-touch-callout: default;
        pointer-events: none; 
    }
    
    /* å½“é€‰ä¸­ 'Select Text' æˆ– 'Highlight' å·¥å…·æ—¶ï¼Œä¸º Text Layer å¯ç”¨ç‚¹å‡»/é€‰ä¸­ */
    .page-wrapper.select-text-active .textLayer {
        pointer-events: auto;
        z-index: 10;              /* iOS ä¸Šæ›´ç¨³ï¼šç¡®ä¿ textLayer åœ¨æœ€ä¸Šå±‚æ¥æ”¶è§¦æ‘¸ */
    }

    /* ç¡®ä¿åœ¨é€‰ä¸­æ¨¡å¼ä¸‹ï¼Œæ³¨é‡Šå±‚ä¸æ‹¦æˆªè§¦æ‘¸ï¼ˆå¹¶ä¸‹æ²‰åˆ° textLayer ä¸‹é¢ï¼‰ */
    .page-wrapper.select-text-active .annoCanvas {
        pointer-events: none !important;
        z-index: 1;
    }
    /* iOS/Android: make sure selection is not blocked by ancestor styles */
    .page-wrapper.select-text-active {
        -webkit-user-select: text;
        user-select: text;
    }
    .page-wrapper.select-text-active .textLayer > div {
        pointer-events: auto;
        -webkit-user-select: text;
        user-select: text;
        -webkit-touch-callout: default;
    }
.textLayer > div {
        position: absolute;
        white-space: pre;
        transform-origin: 0% 0%;
        cursor: text !important; 
    }
    
    /* æ–‡æœ¬é€‰ä¸­è§†è§‰åé¦ˆï¼šæµ…è“è‰²èƒŒæ™¯ */
    .textLayer ::selection {
      background: rgba(173, 216, 230, 0.5); 
      color: inherit;
    }
    .textLayer ::-moz-selection {
      background: rgba(173, 216, 230, 0.5); 
      color: inherit;
    }

    /* Dynamic text input for inline editing */
    #annotationInput {
        position: absolute; 
        border: 1px dashed black; 
        box-sizing: content-box;
        padding: 0;
        margin: 0;
        line-height: 1.2; 
        background: rgba(255, 255, 255, 0.9);
        z-index: 100;
        resize: none; 
        overflow: hidden; 
    }
    
    /* æ‹–åŠ¨é¢„è§ˆå…ƒç´ æ ·å¼ */
    #dragPreview {
        display: none; 
        position: absolute; 
        z-index: 99;
        white-space: pre-wrap;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
        line-height: 1.2;
        background: rgba(255, 255, 255, 0.8);
        pointer-events: none; 
    }

    /* Signature Modal Styles (omitted for brevity, assume unchanged) */
    #signatureModal {
        display: none; 
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4); 
        padding-top: 50px;
    }
    #signatureContent {
        background-color: #fefefe;
        margin: 5% auto; 
        padding: 20px;
        border: 1px solid #888;
        width: 80%; 
        max-width: 600px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    }
    #signaturePadCanvas {
        border: 1px solid #000;
        background: #fff;
        display: block;
        cursor: crosshair;
        width: 100%; 
        height: 200px; 
    }
    .modal-buttons {
        margin-top: 10px;
        text-align: right;
    }

	/* ç§»åŠ¨è®¾å¤‡å“åº”å¼ä¼˜åŒ– */
	@media (max-width: 1200px) { /* å°† 600px æ‰©å¤§åˆ° 1200px å·¦å³ï¼Œè¦†ç›–ç»å¤§å¤šæ•°å¹³æ¿å’Œç¬”è®°æœ¬ç”µè„‘ */
		body { margin: 8px; }
		.toolbar { flex-direction: column; gap: 12px; align-items: flex-start; }
		.row, .page-controls, .tools { width: 100%; box-sizing: border-box; }
		.tools { flex-wrap: wrap; flex-direction: row; gap: 6px; }
		.tools button { flex-grow: 1; min-width: 36px; max-width: none; }
		.tools input[type="color"] { width: 36px; height: 36px; padding: 2px; flex-grow: 0; }
		#fontSize { width: 60px; flex-grow: 0; }
		.page-controls { flex-wrap: wrap; gap: 8px; }
		.page-controls input { width: 60px !important; }
		
		/* æ ¸å¿ƒä¿®æ”¹ï¼šå¼ºåˆ¶ PDF å®¹å™¨å’Œ Canvas å®½åº¦ 100% é€‚é…çˆ¶å®¹å™¨ */
		.page-wrapper { 
			width: 100% !important; 
			max-width: 100%; 
			/* ç§»é™¤ style="width: ${canvas.width}px;" å¸¦æ¥çš„å›ºå®šåƒç´ é™åˆ¶ */
			/* PDF æ¸²æŸ“çš„ canvas åƒç´ å°ºå¯¸ï¼ˆcanvas.width/heightï¼‰ä¸å˜ï¼Œä½†å…¶ display å°ºå¯¸ï¼ˆwidth/heightï¼‰å°†ç”± CSS æ§åˆ¶ */
		}
		.pdfCanvas, .annoCanvas, .textLayer {
			width: 100% !important; 
			height: auto !important; 
			max-width: 100%;
		}
	}
    
  </style>
  <meta name="google-adsense-account" content="ca-pub-7563681675733550">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7563681675733550"
     crossorigin="anonymous"></script>
</head>
<body>
  <h2>PDF Upload, Inline Annotation & Download</h2>

  <div class="toolbar">
    <div class="row">
      <span class="label">Choose PDF:</span>
      <input type="file" id="fileInput" accept="application/pdf" />
    </div>
    
    <div class="page-controls">
      <span class="label">Total Pages: <span id="pageCount">0</span></span>
      <label for="pageInput">Go to Page:</label>
      <input type="number" id="pageInput" min="1" value="1" style="width: 50px;" disabled />
      <button id="goToPageBtn" disabled title="Go">â¡ï¸</button>
    </div>

    <div class="tools">
      <span class="label">Tools:</span>
      <button id="toolMouse" title="Select/Move">ğŸ–±ï¸</button> 
      <button id="toolSelectText" title="Select Text">I</button> 
      <button id="toolText" title="Add Text">T</button>
      <button id="toolHighlight" title="Highlight">ğŸ–ï¸</button>
      <button id="toolSignature" title="Signature">âœï¸</button>
      <button id="toolDelete" title="Delete">ğŸ—‘ï¸</button>
      <input id="colorInput" type="color" value="#ff0000" title="Color" />
      <select id="fontSize">
        <option value="12">12px</option>
        <option value="14" selected>14px</option>
        <option value="18">18px</option>
        <option value="24">24px</option>
        <option value="32">32px</option>
      </select>
	  <button id="undoBtn" disabled title="Undo">â†©ï¸</button>
      <button id="redoBtn" disabled title="Redo">â†ªï¸</button>
      <button id="downloadBtn" disabled title="Download">â¬‡ï¸</button>
    </div>
  </div>

  <div class="hint">Tip: Use mouse wheel or arrow keys to scroll through pages. ğŸ–±ï¸ = Select/Move existing Text or Signature. I = Select text on the PDF (I-beam cursor). T = click to place, DOUBLE-CLICK to edit, drag to move. ğŸ–ï¸ = select text to highlight. âœï¸ = open signature pad. ğŸ—‘ï¸ = click on an annotation to remove.</div>

  <div id="pdf-viewer-wrapper">
    </div>

  <textarea id="annotationInput" style="display:none;"></textarea>
  <div id="dragPreview"></div> 
  
  <div id="signatureModal">
      <div id="signatureContent">
          <h3>Draw Your Signature</h3>
          <canvas id="signaturePadCanvas" width="560" height="200"></canvas>
          <div class="modal-buttons">
              <button id="clearSignatureBtn">Clear</button>
              <button id="saveSignatureBtn">Save and Place</button>
              <button id="closeSignatureBtn">Cancel</button>
          </div>
      </div>
  </div>
  
  <div style="margin-top: 30px; padding: 20px; text-align: center; border-top: 1px solid #ddd;">
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-7563681675733550"
     data-ad-slot="9227935901"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle || []).push({});
</script>
  </div>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FCQP2T463K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FCQP2T463K');
</script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    // --- ä¿®å¤: ç¡®ä¿æ‰€æœ‰å˜é‡åœ¨è¢«ä½¿ç”¨å‰éƒ½è¢«æ­£ç¡®å®šä¹‰å’Œèµ‹å€¼ ---
    const fileInput = document.getElementById('fileInput');
    const pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');
    const pageCountSpan = document.getElementById('pageCount');

    const toolMouseBtn = document.getElementById('toolMouse'); 
    const toolSelectTextBtn = document.getElementById('toolSelectText'); 
    const toolTextBtn = document.getElementById('toolText');
    const toolHighlightBtn = document.getElementById('toolHighlight');
    const toolDeleteBtn = document.getElementById('toolDelete');
    const toolSignatureBtn = document.getElementById('toolSignature');

    const colorInput = document.getElementById('colorInput');
    const fontSizeSelect = document.getElementById('fontSize');
    const downloadBtn = document.getElementById('downloadBtn');
    const undoBtn = document.getElementById('undoBtn'); 
    const redoBtn = document.getElementById('redoBtn'); 
    const annotationInput = document.getElementById('annotationInput'); 
    const dragPreview = document.getElementById('dragPreview'); 
    const pdfLib = window.PDFLib;
    const pageInput = document.getElementById('pageInput');
    const goToPageBtn = document.getElementById('goToPageBtn');
    
    // Signature Elements
    const signatureModal = document.getElementById('signatureModal');
    const signaturePadCanvas = document.getElementById('signaturePadCanvas');
    const clearSignatureBtn = document.getElementById('clearSignatureBtn');
    const saveSignatureBtn = document.getElementById('saveSignatureBtn');
    const closeSignatureBtn = document.getElementById('closeSignatureBtn');
    let signatureCtx = signaturePadCanvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // Cache for signature images to ensure synchronous drawing
    let signatureImageCache = new Map();


    let pdfDoc = null;
    let originalFile = null; 
    let annotations = []; 
    let history = []; 
    let redoHistory = [];
    const MAX_HISTORY = 10; 

    let currentTool = 'mouse'; // DEFAULT TO MOUSE/MOVE TOOL 
    let dragStart = null; 
    let dragEnd = null;
    
    let activeAnno = null; 
    let activeAnnoPage = -1; 
    let activeAnnoCanvas = null; 
    let activePageWrapper = null; 

    let dragAnno = null; 
    let dragOffset = {x: 0, y: 0}; 
    let isDragging = false; 
    
    // çŠ¶æ€å˜é‡ï¼šç”¨äºå­˜å‚¨ Signature æ”¾ç½®ä½ç½®
    let signaturePlacementPos = null;
    let signaturePlacementPageNum = -1;

    annotationInput.addEventListener('blur', (e) => {
        if (activeAnno) {
            (async () => {
                 await finalizeText();
            })();
        }
    });
    
    // --- æ–‡æœ¬æ³¨é‡Šçš„é¢œè‰²å’Œå¤§å°ä¸è·Ÿéšå·¥å…·æ å˜åŠ¨ ---
    colorInput.addEventListener('change', (e) => {
        if (activeAnno && activeAnno.type === 'text') {
            saveState(); 
            activeAnno.color = e.target.value;
            annotationInput.style.color = e.target.value;
            annotationInput.style.borderColor = e.target.value;
        }
    });

    fontSizeSelect.addEventListener('change', (e) => {
        if (activeAnno && activeAnno.type === 'text') {
            saveState(); 
            const newSize = parseInt(e.target.value, 10);
            activeAnno.fontSize = newSize;
            annotationInput.style.fontSize = `${newSize}px`;
            annotationInput.style.lineHeight = `${newSize * 1.2}px`; 
        }
    });
    
    
    // --- NEW: Function to control the pointer events and cursor ---
    function updateAnnotationCanvasPointerEvents(toolName) {
        const pageWrappers = document.querySelectorAll('.page-wrapper');
        const newCursor = (toolName === 'select_text' || toolName === 'highlight') ? 'text' : 'default'; 
        
        pageWrappers.forEach(pageWrapper => {
            pageWrapper.style.cursor = newCursor; 

            if (toolName === 'select_text' || toolName === 'highlight') { 
                 pageWrapper.classList.add('select-text-active');
            } else {
                 pageWrapper.classList.remove('select-text-active');
            }
        });
        
        pdfViewerWrapper.style.cursor = 'default';
    }


    function setTool(button, toolName) {
      if (activeAnno) {
          (async () => { await finalizeText(); })();
      }
      
      dragAnno = null;
      dragStart = null;
      isDragging = false;
      dragPreview.style.display = 'none'; 
      
      signaturePlacementPos = null;
      signaturePlacementPageNum = -1;
      
      // æ›´æ–°æŒ‰é’®åˆ—è¡¨
      [toolMouseBtn, toolSelectTextBtn, toolTextBtn, toolHighlightBtn, toolDeleteBtn, toolSignatureBtn].forEach(b => b.classList.remove('tool-active')); 
      button.classList.add('tool-active');
      currentTool = toolName;
      
      if (toolName === 'highlight') {
        colorInput.value = '#ffff00'; // ç¡®ä¿é«˜äº®å·¥å…·ä½¿ç”¨é»„è‰²
      }
      
      // å…³é”®ï¼šæ›´æ–°æ‰€æœ‰ annotation canvas çš„ pointer-events å±æ€§
      updateAnnotationCanvasPointerEvents(currentTool); 
    }

    // Mobile fix: bind both click and touchstart for tool buttons 
    function bindToolButton(btn, toolName) {
      btn.onclick = () => setTool(btn, toolName);
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        setTool(btn, toolName);
      }, { passive: false });
    }

    bindToolButton(toolMouseBtn, 'mouse');
    bindToolButton(toolSelectTextBtn, 'select_text');
    bindToolButton(toolTextBtn, 'text');
    bindToolButton(toolHighlightBtn, 'highlight');
    bindToolButton(toolDeleteBtn, 'delete');
    bindToolButton(toolSignatureBtn, 'signature');

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
    }

    document.addEventListener('DOMContentLoaded', () => {
        toolMouseBtn.click(); // é»˜è®¤å¯ç”¨é¼ æ ‡å·¥å…·
        
        // NEW: å¦‚æœæ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œéšè— Select Text å’Œ Highlight å·¥å…·
        if (isMobileDevice()) {
            toolSelectTextBtn.style.display = 'none';
            toolHighlightBtn.style.display = 'none';
            
            const hintElement = document.querySelector('.hint');
            if (hintElement) {
                 hintElement.innerHTML = 'Tip: Use arrow keys to scroll through pages. ğŸ–±ï¸ = Select/Move existing Text or Signature. T = click to place, DOUBLE-CLICK to edit, drag to move. âœï¸ = open signature pad. ğŸ—‘ï¸ = click on an annotation to remove.';
            }
        }
    });

    // --- History Functions ---
    function saveState() {
        const newState = JSON.parse(JSON.stringify(annotations));
        if (history.length > 0 && JSON.stringify(history[history.length - 1]) === JSON.stringify(newState)) {
            return;
        }
        
        history.push(newState);
        if (history.length > MAX_HISTORY) {
            history.shift();
        }
        redoHistory = []; 
        updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
        undoBtn.disabled = history.length <= 1; 
        redoBtn.disabled = redoHistory.length === 0;
    }
    
    async function preloadSignatureImages() {
        const imagePromises = [];

        for (const pageAnnos of annotations) {
            for (const a of pageAnnos) {
                if (a.type === 'signature' && a.dataUrl && !signatureImageCache.has(a.dataUrl)) {
                    const img = new Image();
                    img.src = a.dataUrl;
                    const loadPromise = new Promise((resolve, reject) => {
                        img.onload = () => resolve();
                        img.onerror = (e) => {
                            console.error("Error loading signature image:", e);
                            resolve(); 
                        };
                    });
                    signatureImageCache.set(a.dataUrl, img);
                    imagePromises.push(loadPromise);
                }
            }
        }
        await Promise.all(imagePromises);
    }
    
    // --- Text Layer Rendering (Essential for Selection) ---
    async function renderTextLayer(page, viewport, textLayerDiv) {
        const textContent = await page.getTextContent();
        const scaleFactor = 1.5; 
        const normalizedViewport = page.getViewport({ scale: 1.0 });

        textLayerDiv.innerHTML = '';
        
        textContent.items.forEach(item => {
            const htmlDiv = document.createElement('div');
            htmlDiv.textContent = item.str;
            
            const txMatrix = item.transform;
            
            // X position (4th element of transform matrix)
            const finalLeft = txMatrix[4] * scaleFactor; 
            
            // Y position calculation:
            const finalTop = normalizedViewport.height * scaleFactor - (txMatrix[5] * scaleFactor + item.height * scaleFactor);

            htmlDiv.style.left = `${finalLeft}px`;
            htmlDiv.style.top = `${finalTop}px`;
            htmlDiv.style.fontSize = `${item.height * scaleFactor}px`;
            htmlDiv.style.height = `${item.height * scaleFactor}px`;
            htmlDiv.style.width = `${item.width * scaleFactor}px`; 
            htmlDiv.style.color = 'transparent';
            htmlDiv.style.position = 'absolute';
            htmlDiv.style.transformOrigin = '0% 0%';
            
            textLayerDiv.appendChild(htmlDiv);
        });
    }


    // --- RENDER LOGIC: Uses dual canvas structure ---
    async function renderAllPages() {
      if (!pdfDoc) return;
      pdfViewerWrapper.innerHTML = ''; 
      
      await preloadSignatureImages(); 

      const scale = 1.5; 
      const numPages = pdfDoc.numPages;
      pageCountSpan.textContent = numPages;
      
      pageInput.max = numPages;
      pageInput.disabled = false;
      goToPageBtn.disabled = false;

      for (let i = 1; i <= numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale });
        
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'page-wrapper';
        pageWrapper.id = `page-wrapper-${i}`; 
        
        const canvas = document.createElement('canvas'); // Base PDF Canvas
        canvas.className = 'pdfCanvas';
        canvas.dataset.pageNum = i;
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        
        // NEW: Text Layer Div (for selection)
        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.dataset.pageNum = i;
        textLayerDiv.style.width = `${canvas.width}px`; 
        textLayerDiv.style.height = `${canvas.height}px`;

        const annoCanvas = document.createElement('canvas'); // Annotation Canvas (Transparent Overlay)
        annoCanvas.className = 'annoCanvas';
        annoCanvas.dataset.pageNum = i;
        annoCanvas.width = canvas.width;
        annoCanvas.height = canvas.height;

        const context = canvas.getContext('2d');
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };
        
        // 1. Render PDF Page
        await page.render(renderContext).promise;
        
        // 2. Render Text Layer for selection
        await renderTextLayer(page, viewport, textLayerDiv);

        // 3. Append elements to the wrapper and viewer
        pageWrapper.appendChild(canvas);
        pageWrapper.appendChild(textLayerDiv);
        pageWrapper.appendChild(annoCanvas);
        pdfViewerWrapper.appendChild(pageWrapper);
        
        // 4. Draw existing annotations on the annotation canvas
        drawAnnotations(annoCanvas, i);
        
        // 5. Add event listeners to annotation canvas
        addPageEventListeners(annoCanvas);
      }
      
      // æ¸²æŸ“å®Œæˆåï¼Œæ ¹æ®å½“å‰å·¥å…·è®¾ç½® pointer-events å’Œ cursor
      updateAnnotationCanvasPointerEvents(currentTool);
    }
	
	async function redrawAllAnnotationLayers() {
        const pageWrappers = document.querySelectorAll('.page-wrapper');
        const redrawPromises = [];
        pageWrappers.forEach(pageWrapper => {
            const annoCanvas = pageWrapper.querySelector('.annoCanvas');
            if (annoCanvas) {
                const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
                redrawPromises.push(redrawAnnotationLayer(annoCanvas, pageNum));
            }
        });
        await Promise.all(redrawPromises);
    }
	
	// --- Undo/Redo Functions ---
    async function undo() {
        if (history.length <= 1) return;

        const currentState = history.pop(); 
        redoHistory.push(currentState);

        const previousState = history[history.length - 1]; 
        annotations = JSON.parse(JSON.stringify(previousState)); 
        
        updateHistoryButtons();
        await redrawAllAnnotationLayers(); 
        if (activeAnno) await finalizeText();
        hideDragPreview();
    }

    async function redo() {
        if (redoHistory.length === 0) return;

        const nextState = redoHistory.pop();
        history.push(nextState);
        
        annotations = JSON.parse(JSON.stringify(nextState)); 
        
        updateHistoryButtons();
        await redrawAllAnnotationLayers(); 
        if (activeAnno) await finalizeText();
        hideDragPreview();
    }

    function redrawAnnotationLayer(annoCanvas, pageNum) {
        const ctx = annoCanvas.getContext('2d');
        ctx.clearRect(0, 0, annoCanvas.width, annoCanvas.height);
        drawAnnotations(annoCanvas, pageNum);
    }

    // --- Annotation Drawing ---
    function drawAnnotations(annoCanvas, pageNum) {
        const ctx = annoCanvas.getContext('2d');
        const pageAnnos = annotations[pageNum - 1] || [];

        pageAnnos.forEach(a => {
            if (dragAnno === a || activeAnno === a) return; 

            ctx.save();
            ctx.globalAlpha = a.type === 'highlight' ? 0.35 : 1.0;
            ctx.fillStyle = a.color;
            ctx.strokeStyle = a.color;

            if (a.type === 'text') {
                ctx.globalAlpha = 1.0;
                ctx.font = `${a.fontSize}px sans-serif`;
                ctx.fillStyle = a.color;
                
                const lines = a.text.split('\n');
                const lineHeight = a.fontSize * 1.2;
                let estimatedWidth = 100;

                lines.forEach((line, index) => {
                    ctx.fillText(line, a.x, a.y + a.fontSize + index * lineHeight);
                    estimatedWidth = Math.max(estimatedWidth, ctx.measureText(line).width);
                });
                
                // Draw dashed border
                ctx.save();
                ctx.strokeStyle = `rgba(${parseInt(a.color.slice(1, 3), 16)}, ${parseInt(a.color.slice(3, 5), 16)}, ${parseInt(a.color.slice(5, 7), 16)}, 0.6)`;
                ctx.setLineDash([4, 4]);
                const textWidth = estimatedWidth + 5;
                const textHeight = lines.length * lineHeight + 5;
                ctx.strokeRect(a.x - 2, a.y - 2, textWidth, textHeight);
                ctx.restore();
                
            } else if (a.type === 'highlight') {
                 // Use fillRect to draw the highlight box
                ctx.fillRect(a.x, a.y, a.w, a.h);
            } else if (a.type === 'signature') {
                const img = signatureImageCache.get(a.dataUrl);
                if (img) {
                    ctx.drawImage(img, a.x, a.y, a.w, a.h);
                }
            }

            ctx.restore();
        });
    }


    // --- Interaction Logic (Mouse/Touch Handlers) ---
    function isInsideAnnotation(point, anno, canvas) {
        if (anno.type === 'highlight') {
            const minX = Math.min(anno.x, anno.x + anno.w);
            const maxX = Math.max(anno.x, anno.x + anno.w);
            const minY = Math.min(anno.y, anno.y + anno.h);
            const maxY = Math.max(anno.y, anno.y + anno.h);
            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
        } else if (anno.type === 'text') {
            const lines = anno.text.split('\n');
            const lineHeight = anno.fontSize * 1.2;
            let maxWidth = 0;
            const ctx = canvas.getContext('2d');
            ctx.font = `${anno.fontSize}px sans-serif`;
            lines.forEach(line => {
                maxWidth = Math.max(maxWidth, ctx.measureText(line).width);
            });
            
            const minW = 50; 
            const minH = anno.fontSize * 1.2; 

            const textWidth = Math.max(maxWidth + 5, minW); 
            const textHeight = Math.max(lines.length * lineHeight + 5, minH); 

            return point.x >= anno.x && point.x <= anno.x + textWidth && 
                   point.y >= anno.y && point.y <= anno.y + textHeight;

        } else if (anno.type === 'signature') {
             return point.x >= anno.x && point.x <= anno.x + anno.w && 
                    point.y >= anno.y && point.y <= anno.y + anno.h;
        }
        return false;
    }

    function getCanvasPos(evt, canvas) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else {
            clientX = evt.clientX;
            clientY = evt.clientY;
        }
        
        return { 
            x: (clientX - rect.left) * (canvas.width / rect.width), 
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    }
    
    function setupDragPreview(anno, annoCanvas) {
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;
        
        if (anno.type === 'text') {
            const fontSize = anno.fontSize;
            const lineHeight = fontSize * 1.2;
            
            pageWrapper.appendChild(dragPreview);
            dragPreview.textContent = anno.text;
            dragPreview.style.cssText = `
                display: block;
                position: absolute;
                left: ${anno.x * scaleFactor}px;
                top: ${anno.y * scaleFactor}px;
                color: ${anno.color};
                font-size: ${fontSize}px;
                font-family: sans-serif;
                border: 1px solid ${anno.color};
                min-width: 50px; 
                min-height: ${lineHeight}px; 
                line-height: ${lineHeight}px;
                padding-right: 2px;
                width: fit-content;
                height: fit-content;
                white-space: pre-wrap;
                z-index: 99;
                background: rgba(255, 255, 255, 0.8);
                opacity: 0.8;
            `;
            
        } else if (anno.type === 'signature') {
            const img = signatureImageCache.get(anno.dataUrl);
            if (img) {
                 pageWrapper.appendChild(dragPreview);
                 dragPreview.innerHTML = '';
                 dragPreview.style.cssText = `
                    display: block;
                    position: absolute;
                    left: ${anno.x * scaleFactor}px;
                    top: ${anno.y * scaleFactor}px;
                    width: ${anno.w * scaleFactor}px;
                    height: ${anno.h * scaleFactor}px;
                    border: 1px dashed #000;
                    background-image: url('${anno.dataUrl}');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    z-index: 99;
                    opacity: 0.8;
                 `;
            }
        }
    }

    function hideDragPreview() {
        dragPreview.style.display = 'none';
        dragPreview.innerHTML = '';
        dragPreview.style.backgroundImage = 'none';
    }


    async function handleMouseDown(e, annoCanvas, pageNum) {
        if (e.button === 2) return; // Ignore right-click
        if (currentTool === 'select_text' || currentTool === 'highlight') {
            return; 
        }

        if (activeAnno) {
            await finalizeText();
        }

        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;
        
        // --- SIGNATURE PLACEMENT ACTIVATION LOGIC ---
        if (currentTool === 'signature') {
            signaturePlacementPos = pos;
            signaturePlacementPageNum = pageNum;
            openSignaturePad();
            return; 
        }
        // --- END SIGNATURE PLACEMENT ACTIVATION LOGIC ---

        let pageAnnos = annotations[pageNum - 1] || [];
        const clickedAnno = pageAnnos.find(a => (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas) );

        // --- DRAGGING (MOVE) LOGIC ---
        if ((currentTool === 'mouse' || currentTool === 'text') && clickedAnno) {
            saveState();
            dragAnno = clickedAnno;
            dragOffset = {x: pos.x - clickedAnno.x, y: pos.y - clickedAnno.y};
            setupDragPreview(dragAnno, annoCanvas);
            await redrawAnnotationLayer(annoCanvas, pageNum);
            isDragging = true;
			if (e.touches) {
				e.preventDefault();
			}
            return;
        }

        // --- DELETE Tool Logic ---
        if (currentTool === 'delete') {
            const annoToDelete = pageAnnos.find(a => isInsideAnnotation(pos, a, annoCanvas));
            if (annoToDelete) {
                saveState();
                annotations[pageNum - 1] = pageAnnos.filter(a => a !== annoToDelete);
                await redrawAnnotationLayer(annoCanvas, pageNum);
            }
            dragStart = null;
            return;
        }
        
        // --- CREATION LOGIC (Text) ---
        if (currentTool === 'text' && !clickedAnno && !activeAnno) {
            const fontSize = parseInt(fontSizeSelect.value, 10);
            const newAnno = {
                type: 'text',
                x: pos.x,
                y: pos.y,
                color: colorInput.value,
                text: 'New Text',
                fontSize: fontSize,
            };
            saveState();
            annotations[pageNum - 1].push(newAnno);
            await activateTextEdit(newAnno, pageNum, annoCanvas);
            dragStart = null;
            return;
        }

        dragStart = null;
        dragEnd = null;
    }

    // Handles dragging/hover
    function handleMouseMove(e, annoCanvas, pageNum) {
        if (currentTool === 'select_text' || currentTool === 'highlight') return;
        
        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;

        // 1. Dragging Annotation
        if (isDragging && dragAnno) {
            const rect = annoCanvas.getBoundingClientRect();
            const scaleFactor = rect.width / annoCanvas.width;
            
            dragAnno.x = pos.x - dragOffset.x;
            dragAnno.y = pos.y - dragOffset.y;
            
            // Update drag preview position
            dragPreview.style.left = `${dragAnno.x * scaleFactor}px`;
            dragPreview.style.top = `${dragAnno.y * scaleFactor}px`;
			
            return;
        }
        
        // 2. Cursor/Hover feedback
        if (currentTool === 'mouse' || currentTool === 'delete') {
            const pageAnnos = annotations[pageNum - 1] || [];
            const hoveredAnno = pageAnnos.find(a => (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas) );
            
            if (hoveredAnno) {
                annoCanvas.style.cursor = currentTool === 'delete' ? 'crosshair' : 'move';
            } else if (currentTool === 'signature') {
                 annoCanvas.style.cursor = 'crosshair';
            } else {
                annoCanvas.style.cursor = 'default';
            }
        }
    }


    async function handleMouseUp(e, annoCanvas, pageNum) {
        if (currentTool === 'select_text' || currentTool === 'highlight') return;

        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;

        // 1. End Annotation Dragging
        if (dragAnno) {
            if (dragAnno.type === 'text' || dragAnno.type === 'signature') {
                hideDragPreview();
            }
            dragAnno = null;
            dragOffset = {x: 0, y: 0};
            isDragging = false;
            await redrawAnnotationLayer(annoCanvas, pageNum);
            return;
        }
    }


    // --- Handle Text Selection for Highlighting ---
    pdfViewerWrapper.addEventListener('mouseup', handleSelectionHighlight);
    pdfViewerWrapper.addEventListener('touchend', handleSelectionHighlight, { passive: true });
    async function handleSelectionHighlight(e) {
        if (currentTool !== 'highlight') return;
        
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);

        let parentElement = range.commonAncestorContainer.parentElement;
        while(parentElement && !parentElement.classList.contains('textLayer')) {
            parentElement = parentElement.parentElement;
        }
        
        if (!parentElement) { 
            selection.removeAllRanges();
            return;
        }
        
        const pageWrapper = parentElement.closest('.page-wrapper');
        const pageNum = parseInt(pageWrapper.id.split('-')[2], 10);
        const annoCanvas = pageWrapper.querySelector('.annoCanvas');
        if (!annoCanvas) return;
        
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactorX = annoCanvas.width / rect.width;
        const scaleFactorY = annoCanvas.height / rect.height;
        
        const selectionRects = range.getClientRects();
        
        if (selectionRects.length > 0) {
            saveState(); 
        }
        
        let newAnnos = [];
        const color = colorInput.value;
        
        Array.from(selectionRects).forEach(r => {
            const x = (r.left - rect.left) * scaleFactorX;
            const y = (r.top - rect.top) * scaleFactorY;
            const w = r.width * scaleFactorX;
            const h = r.height * scaleFactorY;

            if (w > 2 && h > 2) { 
                 newAnnos.push({
                    type: 'highlight',
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    color: color,
                });
            }
        });
        
        if (newAnnos.length > 0) {
            annotations[pageNum - 1].push(...newAnnos);
            await redrawAnnotationLayer(annoCanvas, pageNum);
        }
        
        selection.removeAllRanges();
    }


    // Handle text annotation double-click for editing
    pdfViewerWrapper.addEventListener('dblclick', handleDoubleClick);
    async function handleDoubleClick(e) {
        if (currentTool !== 'text') return;
        
        let target = e.target;
        while(target && !target.classList.contains('annoCanvas')) {
            target = target.parentNode;
        }
        
        if (!target) return;
        
        const annoCanvas = target;
        const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
        const pos = getCanvasPos(e, annoCanvas);
        
        const pageAnnos = annotations[pageNum - 1] || [];
        const clickedAnno = pageAnnos.find(a => a.type === 'text' && isInsideAnnotation(pos, a, annoCanvas) );
        
        if (clickedAnno) {
            await activateTextEdit(clickedAnno, pageNum, annoCanvas);
        }
    }
    
    // --- Annotation Text Finalization ---
    async function finalizeText() {
        if (!activeAnno) return;
        
        const newText = annotationInput.value;
        const canvasToRedraw = activeAnnoCanvas;
        const pageNum = activeAnnoPage;
        
        annotationInput.style.display = 'none';
        
        if (newText.trim() === '') {
            annotations[pageNum - 1] = annotations[pageNum - 1].filter(a => a !== activeAnno);
        } else {
            activeAnno.text = newText;
        }
        
        activeAnno = null;
        activeAnnoPage = -1;
        activeAnnoCanvas = null;
        activePageWrapper = null;
        
        if (canvasToRedraw) {
            await redrawAnnotationLayer(canvasToRedraw, pageNum);
        }
		
		setTool(toolMouseBtn, 'mouse');
    }

    async function activateTextEdit(anno, pageNum, annoCanvas) {
        if (activeAnno) {
            await finalizeText();
        }
        
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;
        const fontSize = anno.fontSize;
        const lineHeight = fontSize * 1.2;

        pageWrapper.appendChild(annotationInput);

        const left = (anno.x * scaleFactor);
        const top = (anno.y * scaleFactor);
        
        annotationInput.value = anno.text;
        
        annotationInput.style.cssText = `
            display: block;
            position: absolute;
            left: ${left}px;
            top: ${top}px;
            color: ${anno.color};
            font-size: ${fontSize}px;
            font-family: sans-serif;
            border: 1px dashed ${anno.color};
            min-width: 50px;
            min-height: ${lineHeight}px;
            line-height: ${lineHeight}px;
            padding-right: 2px;
            width: fit-content;
            height: fit-content;
            white-space: pre-wrap;
            z-index: 100;
        `;
        
        activeAnno = anno;
        activeAnnoPage = pageNum;
        activeAnnoCanvas = annoCanvas;
        activePageWrapper = pageWrapper;
        
        colorInput.value = anno.color;
        fontSizeSelect.value = anno.fontSize.toString();

        await redrawAnnotationLayer(annoCanvas, pageNum); 
        
        window.requestAnimationFrame(() => {
            annotationInput.focus();
            annotationInput.select();
        });
    }


    // --- Signature Modal and Logic ---
    function openSignaturePad() {
        if (!signaturePlacementPos) return; 
        setupSignaturePad();
        signatureModal.style.display = 'block';
    }

    function closeSignaturePad() {
        signatureModal.style.display = 'none';
        signaturePlacementPos = null;
        signaturePlacementPageNum = -1;
    }
    
    closeSignatureBtn.onclick = closeSignaturePad;
    clearSignatureBtn.onclick = setupSignaturePad;
    saveSignatureBtn.onclick = () => {
        saveAndPlaceSignature();
    };

    function setupSignaturePad() {
        signaturePadCanvas.width = 560;
        signaturePadCanvas.height = 200;
        signatureCtx.clearRect(0, 0, signaturePadCanvas.width, signaturePadCanvas.height);
        isDrawing = false;
        signatureCtx.strokeStyle = colorInput.value; 
        signatureCtx.lineWidth = parseInt(fontSizeSelect.value, 10) / 4; 
        signatureCtx.lineCap = 'round';
    }

    function draw(e) {
        if (!isDrawing) return;
        signatureCtx.beginPath();
        signatureCtx.moveTo(lastX, lastY);
        signatureCtx.lineTo(e._x, e._y);
        signatureCtx.stroke();
        [lastX, lastY] = [e._x, e._y];
    }
    
    function handleSignatureMove(e) {
        if (!isDrawing) return;
        const rect = signaturePadCanvas.getBoundingClientRect();
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        e._x = (clientX - rect.left) * scaleX;
        e._y = (clientY - rect.top) * scaleY;
        draw(e);
    }
    
    function handleSignatureStart(e) {
        isDrawing = true;
        const rect = signaturePadCanvas.getBoundingClientRect();
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        e._x = (clientX - rect.left) * scaleX;
        e._y = (clientY - rect.top) * scaleY;

        [lastX, lastY] = [e._x, e._y];
        draw(e);
    }

    function handleSignatureEnd() {
        if (isDrawing) {
            isDrawing = false;
        }
    }

    signaturePadCanvas.addEventListener('mousedown', handleSignatureStart);
    signaturePadCanvas.addEventListener('mousemove', handleSignatureMove);
    signaturePadCanvas.addEventListener('mouseup', handleSignatureEnd);
    signaturePadCanvas.addEventListener('mouseout', handleSignatureEnd);
    signaturePadCanvas.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        handleSignatureStart(e); 
    }, { passive: false });
    signaturePadCanvas.addEventListener('touchmove', (e) => { 
        e.preventDefault(); 
        handleSignatureMove(e); 
    }, { passive: false });
    signaturePadCanvas.addEventListener('touchend', handleSignatureEnd);

    async function saveAndPlaceSignature() {
        if (!signaturePlacementPos || signaturePlacementPageNum === -1) {
            alert("Signature placement position is missing.");
            return;
        }
        
        const dataUrl = signaturePadCanvas.toDataURL('image/png');
        const pageNum = signaturePlacementPageNum;
        const annoCanvas = document.querySelector(`#page-wrapper-${pageNum} .annoCanvas`);

        if (!annoCanvas) {
            console.error("Could not find annotation canvas for page", pageNum);
            return;
        }

        const isEmpty = isCanvasEmpty(signaturePadCanvas, signatureCtx);
        if (isEmpty) {
            alert("The signature pad is empty. Please draw your signature.");
            return;
        }
        
        const width = 150; 
        const height = 60;
        
        const newAnno = {
            type: 'signature',
            x: signaturePlacementPos.x - width / 2, 
            y: signaturePlacementPos.y - height / 2,
            w: width,
            h: height,
            color: colorInput.value, 
            dataUrl: dataUrl,
        };
        
        saveState();
        annotations[pageNum - 1].push(newAnno);
        
        const img = new Image();
        img.src = dataUrl;
        signatureImageCache.set(dataUrl, img);
        await new Promise(resolve => {
            img.onload = resolve;
            img.onerror = resolve; 
        });
        
        signatureModal.style.display = 'none';
        await redrawAnnotationLayer(annoCanvas, pageNum);

        signaturePlacementPos = null;
        signaturePlacementPageNum = -1;
        setTool(toolMouseBtn, 'mouse'); // Switch to mouse tool after placement
    }

    function isCanvasEmpty(canvas, ctx) {
        const pixelBuffer = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
        return !pixelBuffer.some(color => color !== 0xFFFFFFFF && color !== 0x00000000); 
    }

    // --- Core PDF Functions ---
    async function openPdfFromFile(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            pdfDoc = await loadingTask.promise;
            originalFile = file; 
            annotations = Array.from({ length: pdfDoc.numPages }, () => []);
            signatureImageCache.clear();
            history = [];
            redoHistory = [];
            saveState();
            await renderAllPages();
            
            updateAnnotationCanvasPointerEvents(currentTool);
            downloadBtn.disabled = false;
        } catch (error) {
            console.error("PDF Loading Error:", error);
            alert("Error loading PDF. Please check the browser console (F12) for details.");
            pdfViewerWrapper.innerHTML = 'PDF loading failed.';
            pdfDoc = null;
            downloadBtn.disabled = true;
        }
    }

    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        await openPdfFromFile(file);
    });

    function addPageEventListeners(annoCanvas) {
        const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
        const asyncHandler = (fn) => (e) => {
            if (e.touches && (currentTool === 'highlight' || currentTool === 'mouse') && isDragging) {
                e.preventDefault();
            }
            fn(e, annoCanvas, pageNum).catch(console.error);
        };

        const touchMoveHandler = (e) => {
            if (isDragging) {
                e.preventDefault();
            }
            handleMouseMove(e, annoCanvas, pageNum);
        };
        
        // Mouse events
        annoCanvas.addEventListener('mousedown', asyncHandler(handleMouseDown));
        annoCanvas.addEventListener('mousemove', (e) => handleMouseMove(e, annoCanvas, pageNum));
        annoCanvas.addEventListener('mouseup', asyncHandler(handleMouseUp));
        
        // Touch events: 
        annoCanvas.addEventListener('touchstart', asyncHandler(handleMouseDown), { passive: false });
        annoCanvas.addEventListener('touchmove', touchMoveHandler, { passive: false });
        annoCanvas.addEventListener('touchend', asyncHandler(handleMouseUp));
    }
    
    function goToPage(pageNum) {
        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            pageWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
            pageInput.value = pageNum;
        }
    }
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (pdfDoc) {
            let currentPage = parseInt(pageInput.value, 10);
            let newPage = currentPage;
            
            if (e.key === 'ArrowRight' || e.key === 'PageDown') {
                newPage = Math.min(pdfDoc.numPages, currentPage + 1);
            } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                newPage = Math.max(1, currentPage - 1);
            } else {
                return;
            }
            
            if (newPage !== currentPage) {
                 e.preventDefault(); 
                 goToPage(newPage);
            }
        }
    });

    // Handle jump to page button click
    goToPageBtn.onclick = () => {
        const pageNum = parseInt(pageInput.value, 10);
        if (pdfDoc && pageNum >= 1 && pageNum <= pdfDoc.numPages) {
            goToPage(pageNum);
        } else {
            alert(`Please enter a valid page number between 1 and ${pdfDoc.numPages}`);
            pageInput.value = 1;
        }
    };
	
	// --- å†å²æ“ä½œæŒ‰é’®äº‹ä»¶ç»‘å®š ---
    undoBtn.onclick = () => { 
        undo().catch(console.error); 
    };
    redoBtn.onclick = () => { 
        redo().catch(console.error); 
    };


    
    // --- Helpers for robust color + rendering ---
    function parseColorToRgb01(c) {
        if (!c || typeof c !== 'string') return [0,0,0];
        const s = c.trim();
        if (/^#([0-9a-fA-F]{6})$/.test(s)) {
            const r = parseInt(s.slice(1,3),16)/255;
            const g = parseInt(s.slice(3,5),16)/255;
            const b = parseInt(s.slice(5,7),16)/255;
            return [r,g,b];
        }
        const m = s.match(/^rgba?\(([^)]+)\)$/i);
        if (m) {
            const parts = m[1].split(',').map(x=>x.trim());
            const r = Math.max(0, Math.min(255, parseFloat(parts[0])))/255;
            const g = Math.max(0, Math.min(255, parseFloat(parts[1])))/255;
            const b = Math.max(0, Math.min(255, parseFloat(parts[2])))/255;
            return [r,g,b];
        }
        return [0,0,0];
    }

    function hasNonAscii(str) {
        return /[^\x00-\x7F]/.test(str || "");
    }

    function makeTextPngDataUrl(text, fontPx, colorCss, maxWidthPx) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans CJK SC', 'Noto Sans SC', 'Microsoft YaHei', 'PingFang SC', sans-serif";
        ctx.font = `${fontPx}px ${fontFamily}`;
        ctx.textBaseline = 'top';
        const lines = (text ?? "").split('\n');

        let maxW = 0;
        let totalH = 0;
        const lineH = fontPx * 1.2;
        for (const line of lines) {
            const w = Math.ceil(ctx.measureText(line).width);
            maxW = Math.max(maxW, w);
            totalH += lineH;
        }
        maxW = Math.max(1, Math.min(maxW, maxWidthPx || maxW));
        totalH = Math.max(1, Math.ceil(totalH));

        canvas.width = maxW;
        canvas.height = totalH;

        ctx.font = `${fontPx}px ${fontFamily}`;
        ctx.textBaseline = 'top';
        ctx.fillStyle = colorCss || '#000000';
        ctx.clearRect(0,0,canvas.width,canvas.height);

        let y = 0;
        for (const line of lines) {
            ctx.fillText(line, 0, y);
            y += lineH;
        }
        return canvas.toDataURL('image/png');
    }


    // --- Download PDF Logic (FIXED) ---
    downloadBtn.onclick = async () => {
        if (!pdfDoc) {
            showTopNotification('Please upload a PDF first.', 'failure', 4000);
            return;
        }
        if (activeAnno) {
            await finalizeText();
        }
        
        downloadBtn.disabled = true;
        downloadBtn.textContent = 'Generating...';

        try {
            if (!originalFile) {
                throw new Error("Original PDF file reference is missing.");
            }
            const originalPdfBytes = await originalFile.arrayBuffer();
            const pdf = await pdfLib.PDFDocument.load(originalPdfBytes);
            const pages = pdf.getPages();
            const font = await pdf.embedFont(pdfLib.StandardFonts.Helvetica);

            const signatureEmbedPromises = [];

            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const pageAnnos = annotations[i] || [];
                const pageHeight = page.getHeight();
                
                const currentPageCanvas = document.querySelector(`#page-wrapper-${i + 1} .pdfCanvas`);
                if (!currentPageCanvas) {
                    console.error(`Canvas for page ${i + 1} not found, skipping annotations for this page.`);
                    continue; 
                }
                
                const scaleX = page.getWidth() / currentPageCanvas.width;
                const scaleY = page.getHeight() / currentPageCanvas.height;
                
                pageAnnos.forEach(a => {
                    if (a.type === 'text') {
                        const lines = a.text.split('\n');
                        const lineHeight = a.fontSize * 1.2;
                        
                        lines.forEach((line, index) => {
                            const x = a.x * scaleX;
                            const yTopCanvas = a.y + a.fontSize + index * lineHeight; 
                            const y = pageHeight - (yTopCanvas * scaleY);

                            const [r01, g01, b01] = parseColorToRgb01(a.color);

                            if (hasNonAscii(line)) {
                                signatureEmbedPromises.push(async () => {
                                    const dataUrl = makeTextPngDataUrl(line, a.fontSize, a.color, currentPageCanvas.width);
                                    const pngImage = await pdf.embedPng(dataUrl);

                                    const imgW = pngImage.width * scaleX;
                                    const imgH = pngImage.height * scaleY;

                                    const yTopTextCanvas = a.y + index * lineHeight; 
                                    const yImg = pageHeight - ((yTopTextCanvas + pngImage.height) * scaleY);

                                    page.drawImage(pngImage, {
                                        x: x,
                                        y: yImg,
                                        width: imgW,
                                        height: imgH,
                                        opacity: 1.0,
                                    });
                                });
                            } else {
                                page.drawText(line, {
                                    x: x,
                                    y: y,
                                    font: font,
                                    size: a.fontSize * scaleX, 
                                    color: pdfLib.rgb(r01, g01, b01),
                                });
                            }
                        });
                    } else if (a.type === 'highlight') {
                        const [r, g, b] = parseColorToRgb01(a.color);

                        const x = a.x * scaleX;
                        const yTopCanvas = a.y; 
                        const y = pageHeight - ((yTopCanvas + a.h) * scaleY); 
                        const w = a.w * scaleX;
                        const h = a.h * scaleY;

                        page.drawRectangle({
                            x: x,
                            y: y,
                            width: w,
                            height: h,
                            color: pdfLib.rgb(r, g, b),
                            opacity: 0.35,
                            borderWidth: 0
                        });
                    } else if (a.type === 'signature') {
                        signatureEmbedPromises.push(async () => {
                            const pngImage = await pdf.embedPng(a.dataUrl); 
                            
                            const x = a.x * scaleX;
                            const yTopCanvas = a.y; 
                            const y = pageHeight - ((yTopCanvas + a.h) * scaleY); 
                            const w = a.w * scaleX;
                            const h = a.h * scaleY;

                            page.drawImage(pngImage, {
                                x: x, 
                                y: y, 
                                width: w, 
                                height: h,
                                opacity: 1.0, 
                            });
                        });
                    }
                });
            }

            await Promise.all(signatureEmbedPromises.map(p => p()));

            const pdfBytes = await pdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob); 

            const a = document.createElement('a');
            a.href = url;
            const name = (originalFile && originalFile.name) ? originalFile.name.replace(/\.pdf$/i, '') : 'document';
            const fileName = `${name}-annotated.pdf`;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
			
            // --- NEW: ä¼ é€’æ–‡ä»¶åå’Œ Blob URL ---
			showTopNotification(`' ${fileName} ' is downloaded successfully! Click to open.`, 'success', 10000, fileName, url); 
            
        } catch (error) {
            console.error("PDF Download Error:", error);
			showTopNotification('File download failed...Please click this bar to send email to administrator', 'failure', 10000); 
        } finally {
            downloadBtn.textContent = 'â¬‡ï¸';
            downloadBtn.disabled = false;
        }
    };
	
	// NEW: Top Notification Function (Updated for Clickable Filename)
	let notificationTimeout = null;
	const NOTIFICATION_ID = 'topNotification';

	/**
	 * æ˜¾ç¤ºé¡¶éƒ¨é€šçŸ¥æ 
	 * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯ã€‚
	 * @param {'success'|'failure'} type - é€šçŸ¥ç±»å‹ã€‚
	 * @param {number} duration - é€šçŸ¥æ˜¾ç¤ºæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰ã€‚
	 * @param {string} [fileName=null] - ä»…åœ¨ success æ—¶ä½¿ç”¨ï¼Œè¦æ˜¾ç¤ºçš„æ–‡ä»¶åã€‚
	 * @param {string} [fileUrl=null] - ä»…åœ¨ success æ—¶ä½¿ç”¨ï¼Œä¸‹è½½æ–‡ä»¶çš„ Blob URLã€‚
	 */
	function showTopNotification(message, type = 'success', duration = 6000, fileName = null, fileUrl = null) {
		let notificationDiv = document.getElementById(NOTIFICATION_ID);
		if (!notificationDiv) {
			notificationDiv = document.createElement('div');
			notificationDiv.id = NOTIFICATION_ID;
			document.body.appendChild(notificationDiv);
		}

		// æ¸…é™¤ä¸Šä¸€æ¬¡çš„ç±»å’Œç‚¹å‡»äº‹ä»¶
		notificationDiv.className = '';
		notificationDiv.classList.add('notification-' + type);
		
		notificationDiv.innerHTML = ''; 

		if (type === 'success' && fileName && fileUrl) {
            // æˆåŠŸï¼šæ˜¾ç¤ºå¯ç‚¹å‡»çš„æ–‡ä»¶å
			const messageParts = message.split(fileName);
			const spanMsg = document.createElement('span');
			spanMsg.textContent = messageParts[0]; 
			notificationDiv.appendChild(spanMsg);

			const fileLink = document.createElement('a');
			fileLink.href = fileUrl;
			fileLink.textContent = fileName;
			fileLink.style.color = 'inherit'; 
			fileLink.style.fontWeight = 'bold';
			fileLink.style.textDecoration = 'underline';
			fileLink.target = '_blank'; 
			
			notificationDiv.onclick = null; 
			notificationDiv.style.cursor = 'default'; 

			notificationDiv.appendChild(fileLink);
			
			const spanMsg2 = document.createElement('span');
			spanMsg2.textContent = messageParts[1] || ''; 
			notificationDiv.appendChild(spanMsg2);
			
		} else if (type === 'failure') {
            // å¤±è´¥ï¼šç‚¹å‡»æ•´ä¸ªé€šçŸ¥æ å‘é€é‚®ä»¶
			notificationDiv.textContent = message;
			notificationDiv.onclick = () => {
				const email = 'panpanr@gmail.com';
				const subject = 'PDF Edit Download Failure Report';
				const body = 'I am reporting a download failure on your PDF tool. Please assist.';
				window.location.href = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
				// ç«‹å³éšè—é€šçŸ¥
				notificationDiv.classList.remove('notification-show');
				notificationDiv.onclick = null; 
			};
			notificationDiv.style.cursor = 'pointer';
		} else {
            // å…¶ä»–æƒ…å†µï¼šæ˜¾ç¤ºçº¯æ–‡æœ¬æ¶ˆæ¯
			notificationDiv.textContent = message;
			notificationDiv.onclick = null;
			notificationDiv.style.cursor = 'default';
		}

        // å…³é”®ï¼šæ·»åŠ  show ç±»ï¼Œè§¦å‘ CSS çš„ opacity: 1 æ¸å˜å…¥åœº
        notificationDiv.classList.add('notification-show');

		if (notificationTimeout) {
			clearTimeout(notificationTimeout);
		}
		
		notificationTimeout = setTimeout(() => {
            // å…³é”®ï¼šç§»é™¤ show ç±»ï¼Œé€šè¿‡ opacity è¿‡æ¸¡å®ç°æ¸å˜æ¶ˆå¤±
			notificationDiv.classList.remove('notification-show'); 
		}, duration);
	}
  </script>
</body>
</html>