<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Upload, Inline Annotation & Download</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { 
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
        margin: 16px auto; 
        max-width: 1000px; 
    }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:flex-start; margin-bottom:12px; } 
    .page-controls { display:flex; gap:8px; align-items:center; }
    .page-container { border:1px solid #ddd; margin-bottom: 10px; } 
    .tools { display:flex; gap:8px; align-items:center; }
    .label { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    .row { margin:8px 0; }
    button, input, select { padding:6px 10px; font-size:14px; }
    .tool-active { background:#1f6feb; color:white; }
    
    #pdf-viewer-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center; 
        width: 100%;
    }
    
    .page-wrapper {
        position: relative; 
        display: inline-block; 
        margin-bottom: 10px; 
        box-shadow: 0 0 5px rgba(0,0,0,0.1);
    }
    
    .pdfCanvas, .annoCanvas {
        display: block;
    }

    /* CRITICAL FIX for flickering: Annotation Canvas Overlay */
    .annoCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 5; 
        pointer-events: auto; 
    }

    /* Dynamic text input for inline editing */
    #annotationInput {
        position: absolute; 
        border: 1px dashed black; 
        box-sizing: content-box;
        padding: 0;
        margin: 0;
        line-height: 1.2; 
        background: rgba(255, 255, 255, 0.9);
        z-index: 100;
        resize: none; 
        overflow: hidden; 
    }
    
    /* ÊãñÂä®È¢ÑËßàÂÖÉÁ¥†Ê†∑Âºè */
    #dragPreview {
        display: none; 
        position: absolute; 
        z-index: 99;
        white-space: pre-wrap;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
        line-height: 1.2;
        background: rgba(255, 255, 255, 0.8);
        pointer-events: none; 
    }

    /* Signature Modal Styles */
    #signatureModal {
        display: none; 
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4); 
        padding-top: 50px;
    }
    #signatureContent {
        background-color: #fefefe;
        margin: 5% auto; 
        padding: 20px;
        border: 1px solid #888;
        width: 80%; 
        max-width: 600px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    }
    #signaturePadCanvas {
        border: 1px solid #000;
        background: #fff;
        display: block;
        cursor: crosshair;
        width: 100%; 
        height: 200px; 
    }
    .modal-buttons {
        margin-top: 10px;
        text-align: right;
    }

    /* ÁßªÂä®ËÆæÂ§áÂìçÂ∫îÂºè‰ºòÂåñ */
    @media (max-width: 600px) {
        body { margin: 8px; }
        .toolbar { flex-direction: column; gap: 12px; align-items: flex-start; }
        .row, .page-controls, .tools { width: 100%; box-sizing: border-box; }
        .tools { flex-wrap: wrap; flex-direction: row; gap: 6px; }
        button, input[type="file"], select { padding: 8px 10px; font-size: 15px; }
        .row input[type="file"] { width: 100%; margin-top: 4px; }
        .tools button { flex-grow: 1; min-width: 70px; }
        .tools input[type="color"] { width: 40px; height: 34px; padding: 2px; flex-grow: 0; }
        #fontSize { width: 70px; flex-grow: 0; }
        .page-controls { flex-wrap: wrap; gap: 8px; }
        .page-controls input { width: 60px !important; }
        /* === PDF Áº©Êîæ‰øÆÊ≠£ (Ê†∏ÂøÉ) === */
        .page-wrapper { width: 100% !important; max-width: 100%; }
        .pdfCanvas, .annoCanvas {
            /* ÂÖ≥ÈîÆÔºöË¶ÜÁõñ JS ËÆæÁΩÆÁöÑÂõ∫ÂÆöÂÉèÁ¥†ÂÆΩÂ∫¶Ôºå‰ΩøÂÖ∂ÈÄÇÂ∫îÂ±èÂπïÔºåÂπ∂‰øùÊåÅÁ∫µÊ®™ÊØî */
            width: 100% !important; 
            height: auto !important; 
            max-width: 100%;
        }
        /* ==================== */
    }
    
  </style>
  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7563681675733550"
     crossorigin="anonymous"></script>
</head>
<body>
  <h2>PDF Upload, Inline Annotation & Download</h2>

  <div class="toolbar">
    <div class="row">
      <span class="label">Choose PDF:</span>
      <input type="file" id="fileInput" accept="application/pdf" />
    </div>
    
    <div class="page-controls">
      <span class="label">Total Pages: <span id="pageCount">0</span></span>
      <label for="pageInput">Go to Page:</label>
      <input type="number" id="pageInput" min="1" value="1" style="width: 50px;" disabled />
      <button id="goToPageBtn" disabled>Go</button>
    </div>

    <div class="tools">
      <span class="label">Tools:</span>
      <button id="toolText">Text</button>
      <button id="toolHighlight">Highlight</button>
      <button id="toolSignature">Signature ‚úçÔ∏è</button>
      <button id="toolDelete">Delete üóëÔ∏è</button>
      <input id="colorInput" type="color" value="#ff0000" title="Color" />
      <select id="fontSize">
        <option value="12">12px</option>
        <option value="14" selected>14px</option>
        <option value="18">18px</option>
        <option value="24">24px</option>
        <option value="32">32px</option>
      </select>
	  <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
      <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
      <button id="downloadBtn" disabled>Download annotated PDF</button>
    </div>
  </div>

  <div class="hint">Tip: Use mouse wheel or arrow keys to scroll through pages. Text = click to place, DOUBLE-CLICK to edit, drag to move. Delete = click on an annotation to remove.</div>

  <div id="pdf-viewer-wrapper">
    </div>

  <textarea id="annotationInput" style="display:none;"></textarea>
  <div id="dragPreview"></div> 
  
  <div id="signatureModal">
      <div id="signatureContent">
          <h3>Draw Your Signature</h3>
          <canvas id="signaturePadCanvas" width="560" height="200"></canvas>
          <div class="modal-buttons">
              <button id="clearSignatureBtn">Clear</button>
              <button id="saveSignatureBtn">Save and Place</button>
              <button id="closeSignatureBtn">Cancel</button>
          </div>
      </div>
  </div>
  
  <div style="margin-top: 30px; padding: 20px; text-align: center; border-top: 1px solid #ddd;">
<!-- PdfEditAd -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-7563681675733550"
     data-ad-slot="9227935901"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
  </div>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FCQP2T463K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FCQP2T463K');
</script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    const fileInput = document.getElementById('fileInput');
    const pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');
    const pageCountSpan = document.getElementById('pageCount');

    const toolTextBtn = document.getElementById('toolText');
    const toolHighlightBtn = document.getElementById('toolHighlight');
    const toolDeleteBtn = document.getElementById('toolDelete');
    const toolSignatureBtn = document.getElementById('toolSignature');

    const colorInput = document.getElementById('colorInput');
    const fontSizeSelect = document.getElementById('fontSize');
    const downloadBtn = document.getElementById('downloadBtn');
    const undoBtn = document.getElementById('undoBtn'); 
    const redoBtn = document.getElementById('redoBtn'); 
    const annotationInput = document.getElementById('annotationInput'); 
    const dragPreview = document.getElementById('dragPreview'); 
    
    const pageInput = document.getElementById('pageInput');
    const goToPageBtn = document.getElementById('goToPageBtn');
    
    // Signature Elements
    const signatureModal = document.getElementById('signatureModal');
    const signaturePadCanvas = document.getElementById('signaturePadCanvas');
    const clearSignatureBtn = document.getElementById('clearSignatureBtn');
    const saveSignatureBtn = document.getElementById('saveSignatureBtn');
    const closeSignatureBtn = document.getElementById('closeSignatureBtn');
    let signatureCtx = signaturePadCanvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // Cache for signature images to ensure synchronous drawing
    let signatureImageCache = new Map();


    let pdfDoc = null;
    let annotations = []; 
    let history = []; 
    let redoHistory = [];
    const MAX_HISTORY = 10; 

    let currentTool = 'text'; 
    let dragStart = null; 
    let dragEnd = null;
    
    let activeAnno = null; 
    let activeAnnoPage = -1; 
    let activeAnnoCanvas = null; 
    let activePageWrapper = null; 

    let dragAnno = null; 
    let dragOffset = {x: 0, y: 0}; 
    let isDragging = false; 

    annotationInput.addEventListener('blur', (e) => {
        if (activeAnno) {
            (async () => {
                 await finalizeText();
            })();
        }
    });

    function setTool(button, toolName) {
      if (activeAnno) {
          (async () => { await finalizeText(); })();
      }
      
      dragAnno = null;
      dragStart = null;
      isDragging = false;
      dragPreview.style.display = 'none'; 
      
      [toolTextBtn, toolHighlightBtn, toolDeleteBtn, toolSignatureBtn].forEach(b => b.classList.remove('tool-active'));
      button.classList.add('tool-active');
      currentTool = toolName;
      
      if (toolName === 'highlight') {
        colorInput.value = '#ffff00'; 
      }
      
      if (toolName === 'signature') {
        // Only open the pad, don't change the tool yet, let the pad handle it
        openSignaturePad();
      }
    }

    toolTextBtn.onclick = () => setTool(toolTextBtn, 'text');
    toolHighlightBtn.onclick = () => setTool(toolHighlightBtn, 'highlight');
    toolDeleteBtn.onclick = () => setTool(toolDeleteBtn, 'delete');
    toolSignatureBtn.onclick = () => setTool(toolSignatureBtn, 'signature');

    document.addEventListener('DOMContentLoaded', () => {
        toolTextBtn.click();
    });

    // --- History Functions ---
    function saveState() {
        const newState = JSON.parse(JSON.stringify(annotations));
        if (history.length > 0 && JSON.stringify(history[history.length - 1]) === JSON.stringify(newState)) {
            return;
        }
        
        history.push(newState);
        if (history.length > MAX_HISTORY) {
            history.shift();
        }
        redoHistory = []; 
        updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
        undoBtn.disabled = history.length <= 1; 
        redoBtn.disabled = redoHistory.length === 0;
    }
    
    // Function to preload all signature images into the cache
    async function preloadSignatureImages() {
        const imagePromises = [];

        for (const pageAnnos of annotations) {
            for (const a of pageAnnos) {
                if (a.type === 'signature' && a.dataUrl && !signatureImageCache.has(a.dataUrl)) {
                    const img = new Image();
                    img.src = a.dataUrl;
                    const loadPromise = new Promise((resolve, reject) => {
                        img.onload = () => resolve();
                        img.onerror = (e) => {
                            console.error("Error loading signature image:", e);
                            resolve(); 
                        };
                    });
                    signatureImageCache.set(a.dataUrl, img);
                    imagePromises.push(loadPromise);
                }
            }
        }
        await Promise.all(imagePromises);
    }


    // --- RENDER LOGIC: Uses dual canvas structure ---
    async function renderAllPages() {
      if (!pdfDoc) return;
      pdfViewerWrapper.innerHTML = ''; 
      
      await preloadSignatureImages(); 

      const scale = 1.5; 
      const numPages = pdfDoc.numPages;
      pageCountSpan.textContent = numPages;
      
      pageInput.max = numPages;
      pageInput.disabled = false;
      goToPageBtn.disabled = false;

      for (let i = 1; i <= numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale });
        
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'page-wrapper';
        pageWrapper.id = `page-wrapper-${i}`; 
        
        const canvas = document.createElement('canvas'); // Base PDF Canvas
        canvas.className = 'pdfCanvas';
        canvas.dataset.pageNum = i;
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        
        const annoCanvas = document.createElement('canvas'); // Annotation Canvas (Transparent Overlay)
        annoCanvas.className = 'annoCanvas';
        annoCanvas.dataset.pageNum = i;
        annoCanvas.width = canvas.width;
        annoCanvas.height = canvas.height;
        
        pageWrapper.style.width = `${canvas.width}px`; 
        
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        annoCanvas.style.width = `${canvas.width}px`; // Match base canvas size
        annoCanvas.style.height = `${canvas.height}px`;

        pageWrapper.appendChild(canvas);
        pageWrapper.appendChild(annoCanvas);
        pdfViewerWrapper.appendChild(pageWrapper);

        // 1. Render PDF to base canvas
        const ctx = canvas.getContext('2d');
        const renderContext = { canvasContext: ctx, viewport };
        await page.render(renderContext).promise;

        // 2. Draw annotations to annotation canvas
        drawAnnotations(annoCanvas, i);
        
        // 3. Add event listeners to annotation canvas
        addPageEventListeners(annoCanvas);
      }
    }
    
    // Function: Only clears and redraws annotations on the annotation canvas
    async function redrawAnnotationLayer(annoCanvas, pageNum) {
        // Clear the annotation canvas
        const ctx = annoCanvas.getContext('2d');
        ctx.clearRect(0, 0, annoCanvas.width, annoCanvas.height);
        
        drawAnnotations(annoCanvas, pageNum);
    }
    
    // --- Annotation Drawing (Takes the annotation canvas) ---
    function drawAnnotations(annoCanvas, pageNum) {
      const ctx = annoCanvas.getContext('2d');
      const pageAnnos = annotations[pageNum - 1] || [];

      pageAnnos.forEach(a => {
        // Do NOT draw the active or dragging element on the canvas
        if (dragAnno === a || activeAnno === a) return; 

        ctx.save();
        ctx.globalAlpha = a.type === 'highlight' ? 0.35 : 1.0;
        ctx.fillStyle = a.color;
        ctx.strokeStyle = a.color;

        if (a.type === 'text') {
          ctx.globalAlpha = 1.0;
          ctx.font = `${a.fontSize}px sans-serif`;
          ctx.fillStyle = a.color;
          
          const lines = a.text.split('\n');
          const lineHeight = a.fontSize * 1.2; 
          
          let estimatedWidth = 100;
          
          lines.forEach((line, index) => {
              // Y position logic: Draw text baseline at y + fontSize
              ctx.fillText(line, a.x, a.y + a.fontSize + index * lineHeight); 
              estimatedWidth = Math.max(estimatedWidth, ctx.measureText(line).width);
          });
          
          // Draw dashed border 
          ctx.save();
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; 
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 3]); 
          
          const linesCount = lines.length || 1;
          const estimatedHeight = linesCount * lineHeight;
            
          // Drawing rectangle from the top of the text box (a.y)
          ctx.strokeRect(a.x, a.y, estimatedWidth + 5, estimatedHeight + 5);
          ctx.restore();

        } else if (a.type === 'highlight') {
          ctx.fillRect(a.x, a.y, a.w, a.h);
        } else if (a.type === 'signature') {
            const img = signatureImageCache.get(a.dataUrl);
            if (img && img.complete) { 
                ctx.save();
                ctx.drawImage(img, a.x, a.y, a.w, a.h);
                
                // Draw dashed border
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; 
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 3]); 
                ctx.strokeRect(a.x, a.y, a.w, a.h);
                
                ctx.restore();
            } else if (img && !img.complete) {
                // If it's not complete, listen for load and redraw only this page
                 img.onload = () => {
                    // This is for newly loaded signatures during a render loop
                    redrawAnnotationLayer(annoCanvas, pageNum).catch(console.error); 
                 };
            }
        }
        ctx.restore();
      });
    }
    
    // Utility to check if a point is inside an annotation's bounding box (unchanged)
    function isInsideAnnotation(point, anno, canvas) {
        if (anno.type === 'highlight' || anno.type === 'signature') {
             return (
                point.x >= anno.x && point.x <= anno.x + anno.w && 
                point.y >= anno.y && point.y <= anno.y + anno.h
            );
        } else if (anno.type === 'text') {
            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.font = `${anno.fontSize}px sans-serif`;
            const lines = anno.text.split('\n');
            const lineHeight = anno.fontSize * 1.2;
            
            let estimatedWidth = 100; 
            lines.forEach(line => {
                estimatedWidth = Math.max(estimatedWidth, ctx.measureText(line).width);
            });
            const linesCount = lines.length || 1;
            const estimatedHeight = linesCount * lineHeight;
            
            ctx.restore();
            
            const x = anno.x;
            const y = anno.y; 
            const padding = 5; 

            return (
                point.x >= x - padding && point.x <= x + estimatedWidth + 5 + padding && 
                point.y >= y - padding && point.y <= y + estimatedHeight + padding
            );
        }
        return false;
    }

    // --- Text Editing & Activation (unchanged) ---
    async function finalizeText() {
        if (!activeAnno || activeAnno.type !== 'text') return;
        
        const newText = annotationInput.value;
        const oldText = activeAnno.text;
        
        const canvasToRedraw = activeAnnoCanvas; 
        const pageNum = activeAnnoPage;

        annotationInput.style.display = 'none';
        annotationInput.value = '';

        if (newText !== oldText && oldText !== '') { 
            saveState(); 
        }

        if (newText.trim() === '') {
            annotations[pageNum - 1] = annotations[pageNum - 1].filter(a => a !== activeAnno);
        } else {
            activeAnno.text = newText;
        }

        activeAnno = null;
        activeAnnoPage = -1;
        activeAnnoCanvas = null;
        activePageWrapper = null;
        
        if (canvasToRedraw) {
            await redrawAnnotationLayer(canvasToRedraw, pageNum);
        }
    }

    async function activateTextEdit(anno, pageNum, annoCanvas) {
        if (activeAnno) {
            await finalizeText();
        }
        
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;
        
        pageWrapper.appendChild(annotationInput); 
        
        const left = (anno.x * scaleFactor); 
        const top = (anno.y * scaleFactor);
        
        const fontSize = anno.fontSize;
        const lineHeight = fontSize * 1.2;
        
        annotationInput.value = anno.text;
        
        annotationInput.style.cssText = `
            display: block;
            position: absolute;
            left: ${left}px;
            top: ${top}px; 
            color: ${anno.color};
            font-size: ${fontSize}px;
            font-family: sans-serif;
            border: 1px dashed ${anno.color}; 
            min-width: 50px;
            min-height: ${lineHeight}px;
            line-height: ${lineHeight}px;
            padding-right: 2px; 
            width: fit-content;
            height: fit-content;
            white-space: pre-wrap; 
            z-index: 100;
        `;
        
        activeAnno = anno;
        activeAnnoPage = pageNum;
        activeAnnoCanvas = annoCanvas;
        activePageWrapper = pageWrapper;
        
        await redrawAnnotationLayer(annoCanvas, pageNum); 

        window.requestAnimationFrame(() => {
            annotationInput.focus();
            setTimeout(() => {
                if (anno.text.length > 0) {
                    annotationInput.select();
                }
            }, 10);
        });
    }

    // --- Drag Preview Setup (unchanged) ---
    function setupDragPreview(anno, annoCanvas) {
        const pageWrapper = annoCanvas.parentNode;
        const rect = annoCanvas.getBoundingClientRect();
        const scaleFactor = rect.width / annoCanvas.width;

        if (anno.type === 'signature') {
            dragPreview.innerHTML = `<img src="${anno.dataUrl}" style="width:100%; height:100%; object-fit: contain;">`;
            dragPreview.style.width = `${anno.w * scaleFactor}px`;
            dragPreview.style.height = `${anno.h * scaleFactor}px`;
            dragPreview.style.color = 'black'; 
            dragPreview.style.fontSize = '1px'; 
            dragPreview.style.lineHeight = '1px';
            dragPreview.style.border = '1px dashed rgba(0, 0, 0, 0.5)';
            dragPreview.style.background = 'transparent'; 
        } else { 
            dragPreview.textContent = anno.text;
            dragPreview.style.color = anno.color;
            dragPreview.style.fontSize = `${anno.fontSize}px`;
            dragPreview.style.fontFamily = 'sans-serif';
            dragPreview.style.lineHeight = `${anno.fontSize * 1.2}px`;
            dragPreview.style.border = '1px dashed rgba(0, 0, 0, 0.5)';
            dragPreview.style.background = 'rgba(255, 255, 255, 0.8)';
            dragPreview.style.width = 'fit-content';
            dragPreview.style.height = 'fit-content';
        }

        dragPreview.style.left = `${anno.x * scaleFactor}px`; 
        dragPreview.style.top = `${anno.y * scaleFactor}px`;
        dragPreview.style.display = 'block';

        pageWrapper.appendChild(dragPreview);
    }
    
    // --- Mouse Handlers (unchanged interaction logic) ---
    async function handleMouseDown(e, annoCanvas, pageNum) {
      const pos = getCanvasPos(e, annoCanvas);
      if (!pos) return;

      let pageAnnos = annotations[pageNum - 1] || [];
      
      dragAnno = null;
      dragStart = pos;
      isDragging = false; 
      dragPreview.style.display = 'none'; 

      const clickedAnno = pageAnnos.find(a => 
          (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas)
      );
      
      if (activeAnno && clickedAnno !== activeAnno) {
          await finalizeText();
          pageAnnos = annotations[pageNum - 1] || [];
      }
      
      // --- DELETE Tool Logic ---
      if (currentTool === 'delete') {
          const annoToDelete = pageAnnos.find(a => isInsideAnnotation(pos, a, annoCanvas));
          if (annoToDelete) {
              saveState();
              annotations[pageNum - 1] = pageAnnos.filter(a => a !== annoToDelete);
              await redrawAnnotationLayer(annoCanvas, pageNum); 
          }
          dragStart = null; 
          return; 
      }

      // --- TEXT Tool Logic (Drag Existing or Create New) ---
      if (currentTool === 'text') {
        
        if (clickedAnno) {
            if (activeAnno !== clickedAnno) { 
                saveState(); 
                dragAnno = clickedAnno;
                dragOffset = {x: pos.x - clickedAnno.x, y: pos.y - clickedAnno.y};
                
                setupDragPreview(dragAnno, annoCanvas);
                await redrawAnnotationLayer(annoCanvas, pageNum); 
            } else {
                 dragStart = null;
            }
        } else {
            if (!activeAnno) {
                const fontSize = parseInt(fontSizeSelect.value, 10);
                const newAnno = {
                    type: 'text',
                    x: pos.x,
                    y: pos.y, 
                    color: colorInput.value,
                    text: '', 
                    fontSize: fontSize,
                };
                annotations[pageNum - 1].push(newAnno);
                dragAnno = newAnno;
                dragOffset = {x: 0, y: 0}; 
            }
        }
        return; 
      } 
    }

    function handleMouseMove(e, annoCanvas, pageNum) {
        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;
        
        const ctx = annoCanvas.getContext('2d');
        
        if (dragStart) {
            dragEnd = pos;
            const distance = Math.sqrt(Math.pow(dragEnd.x - dragStart.x, 2) + Math.pow(dragEnd.y - dragStart.y, 2));
            
            if (distance > 5) { 
                isDragging = true;
            }

            if (dragAnno && isDragging) {
                const newX = dragEnd.x - dragOffset.x;
                const newY = dragEnd.y - dragOffset.y;
                
                dragAnno.x = newX;
                dragAnno.y = newY;
                
                const rect = annoCanvas.getBoundingClientRect();
                const scaleFactor = rect.width / annoCanvas.width;
                dragPreview.style.left = `${newX * scaleFactor}px`;
                dragPreview.style.top = `${newY * scaleFactor}px`;

                return; 
            } 
            
            // Highlight Preview Logic
            if (currentTool === 'highlight') {
                 redrawAnnotationLayer(annoCanvas, pageNum).then(() => {
                    if (!dragEnd) return;
                    const x = Math.min(dragStart.x, dragEnd.x);
                    const y = Math.min(dragStart.y, dragEnd.y);
                    const w = Math.abs(dragEnd.x - dragStart.x);
                    const h = Math.abs(dragEnd.y - dragStart.y);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.35; 
                    ctx.fillStyle = colorInput.value;
                    ctx.fillRect(x, y, w, h);
                    ctx.restore();
                });
                return; 
            }
        }
        
        // --- Hover Cursor (unchanged) --- 
        if ((currentTool === 'text' || currentTool === 'delete') && !dragStart && !activeAnno) { 
            const pageAnnos = annotations[pageNum - 1] || [];
            
            const isOverMovable = pageAnnos.find(a => 
                (a.type === 'text' || a.type === 'signature') && isInsideAnnotation(pos, a, annoCanvas)
            );

            if (currentTool === 'text') {
                annoCanvas.style.cursor = isOverMovable ? 'move' : 'default';
            } else if (currentTool === 'delete') {
                const isOverDeletable = pageAnnos.find(a => isInsideAnnotation(pos, a, annoCanvas));
                annoCanvas.style.cursor = isOverDeletable ? 'pointer' : 'default';
            } else {
                annoCanvas.style.cursor = 'default';
            }
        } else if (currentTool !== 'text' && currentTool !== 'delete') {
            annoCanvas.style.cursor = 'default';
        }
    }

    async function handleMouseUp(e, annoCanvas, pageNum) {
      if (!dragStart) return;
      
      dragEnd = getCanvasPos(e, annoCanvas); 
      if (!dragEnd) {
          dragStart = null;
          isDragging = false;
          return;
      }
      
      const wasDragging = isDragging;
      const currentDragAnno = dragAnno;
      
      dragAnno = null;
      dragStart = null;
      dragEnd = null;
      isDragging = false;
      dragPreview.style.display = 'none'; 
      
      if (currentTool === 'text' && currentDragAnno) { 
        
        if (!wasDragging && currentDragAnno.type === 'text' && currentDragAnno.text.trim() === '') {
            await activateTextEdit(currentDragAnno, pageNum, annoCanvas); 
            return;
        }

        if (wasDragging && currentDragAnno.type === 'text' && currentDragAnno.text.trim() === '') {
            await activateTextEdit(currentDragAnno, pageNum, annoCanvas);
            return;
        }

        await redrawAnnotationLayer(annoCanvas, pageNum); 
        return;
      }

      // Highlight Logic (unchanged)
      if (currentTool === 'highlight') {
        
        const x = Math.min(dragStart.x, dragEnd.x);
        const y = Math.min(dragStart.y, dragEnd.y);
        const w = Math.abs(dragEnd.x - dragStart.x);
        const finalH = Math.abs(dragEnd.y - dragStart.y); 

        if (w > 5 && finalH > 5) {
            saveState(); 
            annotations[pageNum - 1].push({
                type: 'highlight',
                x, y, w, h: finalH, 
                color: colorInput.value
            });
        }
        
        await redrawAnnotationLayer(annoCanvas, pageNum); 
      }
    }
    
    function handleClick(e, annoCanvas, pageNum) {
        // Nothing needed here
    }
    
    async function handleDoubleClick(e, annoCanvas, pageNum) {
        if (activeAnno) {
            await finalizeText(); 
            return; 
        }

        if (currentTool !== 'text') return;

        const pos = getCanvasPos(e, annoCanvas);
        if (!pos) return;
        
        let pageAnnos = annotations[pageNum - 1] || [];
        
        const clickedAnno = pageAnnos.find(a => 
            a.type === 'text' && isInsideAnnotation(pos, a, annoCanvas)
        );
        
        if (clickedAnno) {
            await activateTextEdit(clickedAnno, pageNum, annoCanvas); 
        }
    }
    
    // --- Signature Drawing Logic (FIXED/Simplified) ---
    function setupSignaturePad() {
        // Use fixed dimensions for drawing consistency
        signaturePadCanvas.width = 560; 
        signaturePadCanvas.height = 200; 

        // 1. CLEAR TO TRANSPARENT (Ensures transparent background)
        signatureCtx.clearRect(0, 0, signaturePadCanvas.width, signaturePadCanvas.height); 
        
        // Reset state
        isDrawing = false; 
    }

    function draw(e) {
        if (!isDrawing) return;
        
        signatureCtx.beginPath();
        signatureCtx.moveTo(lastX, lastY);
        signatureCtx.lineTo(e._x, e._y);
        signatureCtx.stroke();
        [lastX, lastY] = [e._x, e._y];
    }

    function handleSignatureStart(e) {
        isDrawing = true;
        const rect = signaturePadCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Scale client coordinates to the actual canvas drawing resolution (560x200)
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        const x = (clientX - rect.left) * scaleX;
        const y = (clientY - rect.top) * scaleY;
        
        [lastX, lastY] = [x, y];
        
        // ********** ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂç≥Êó∂Â∫îÁî®Ê†∑ÂºèÔºåÁ°Æ‰øùÂèØËßÅÊÄß **********
        const selectedFontSize = parseInt(fontSizeSelect.value, 10);
        // Map font size (e.g., 14, 18, 24) to line width, ensuring a minimum of 2
        const calculatedLineWidth = Math.max(2, selectedFontSize / 6); 
        
        signatureCtx.strokeStyle = colorInput.value; // Â∫îÁî®ÈÄâ‰∏≠ÁöÑÈ¢úËâ≤
        signatureCtx.lineWidth = calculatedLineWidth; // Â∫îÁî®ËÆ°ÁÆóÂá∫ÁöÑÁ≤óÁªÜ
        signatureCtx.lineCap = 'round';
        signatureCtx.lineJoin = 'round';
        
        // Á°Æ‰øùËµ∑ÂßãÁÇπÊòØÂèØËßÅÁöÑÔºàÁªòÂà∂‰∏Ä‰∏™ÁÇπÔºâ
        signatureCtx.beginPath();
        signatureCtx.arc(x, y, signatureCtx.lineWidth / 2, 0, 2 * Math.PI, false); 
        signatureCtx.fillStyle = signatureCtx.strokeStyle; // ‰ΩøÁî®ÊèèËæπÈ¢úËâ≤Â°´ÂÖÖÁÇπ
        signatureCtx.fill();
        // ******************************************************

        e._x = x;
        e._y = y;
    }
    
    function handleSignatureMove(e) {
        if (!isDrawing) return;
        
        const rect = signaturePadCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Scale client coordinates to the actual canvas drawing resolution (560x200)
        const scaleX = signaturePadCanvas.width / rect.width;
        const scaleY = signaturePadCanvas.height / rect.height;
        
        e._x = (clientX - rect.left) * scaleX;
        e._y = (clientY - rect.top) * scaleY;
        draw(e);
    }

    function handleSignatureEnd() {
        if (isDrawing) {
            isDrawing = false;
        }
    }
    
    // Use passive: false for touch events to allow preventDefault on drawing
    signaturePadCanvas.addEventListener('mousedown', handleSignatureStart);
    signaturePadCanvas.addEventListener('mousemove', handleSignatureMove);
    signaturePadCanvas.addEventListener('mouseup', handleSignatureEnd);
    signaturePadCanvas.addEventListener('mouseout', handleSignatureEnd);

    signaturePadCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleSignatureStart(e); }, { passive: false });
    signaturePadCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleSignatureMove(e); }, { passive: false });
    signaturePadCanvas.addEventListener('touchend', handleSignatureEnd);


    function openSignaturePad() {
        if (!pdfDoc) {
            alert('Please upload a PDF first.');
            setTool(toolTextBtn, 'text');
            return;
        }
        signatureModal.style.display = 'block';
        setupSignaturePad();
    }

    closeSignatureBtn.onclick = () => {
        signatureModal.style.display = 'none';
        setTool(toolTextBtn, 'text'); 
    }
    
    clearSignatureBtn.onclick = () => {
        setupSignaturePad(); 
    }
    
    saveSignatureBtn.onclick = async () => { 
        if (!pdfDoc) return;

        const firstVisiblePageWrapper = Array.from(pdfViewerWrapper.children).find(el => {
            const rect = el.getBoundingClientRect();
            // Check if the page is at least partially visible
            return rect.top < window.innerHeight && rect.bottom > 0;
        });

        if (!firstVisiblePageWrapper) {
            alert('Cannot determine visible page. Please scroll to a page.');
            return;
        }

        // --- Use annoCanvas for placement ---
        const annoCanvas = firstVisiblePageWrapper.querySelector('.annoCanvas');
        const pageNum = parseInt(annoCanvas.dataset.pageNum, 10);
        
        // Check if the pad is empty
        const imageData = signatureCtx.getImageData(0, 0, signaturePadCanvas.width, signaturePadCanvas.height).data;
        let isEmpty = true;
        // Check if there are any non-transparent pixels (i.e., drawn content)
        for (let i = 3; i < imageData.length; i += 4) { // Start checking from Alpha channel
            if (imageData[i] !== 0) { 
                isEmpty = false;
                break;
            }
        }
        
        if (isEmpty) {
            alert('Please draw your signature before saving.');
            return;
        }
        
        // IMPORTANT: toDataURL('image/png') preserves the alpha channel (transparency)
        const dataUrl = signaturePadCanvas.toDataURL('image/png');
        
        const defaultWidth = 150;
        const defaultHeight = 50;
        
        const canvasRect = annoCanvas.getBoundingClientRect();
        
        // Calculate the scale factor between the CSS display size and the Canvas resolution
        const scaleFactor = annoCanvas.width / canvasRect.width; 
        
        // Center placement on the visible screen area
        const screenCenterX = window.innerWidth / 2;
        const screenCenterY = window.innerHeight / 2;
        
        // Calculate canvas coordinates for placement
        // 1. Get the center point relative to the page wrapper (in CSS pixels)
        const wrapperRect = firstVisiblePageWrapper.getBoundingClientRect();
        const centerCssX = screenCenterX - wrapperRect.left;
        const centerCssY = screenCenterY - wrapperRect.top;
        
        // 2. Convert CSS pixels to Canvas native pixels
        const x = (centerCssX - (defaultWidth / 2)) * scaleFactor;
        const y = (centerCssY - (defaultHeight / 2)) * scaleFactor;

        const newAnno = {
            type: 'signature',
            x: x,
            y: y, 
            w: defaultWidth, 
            h: defaultHeight,
            dataUrl: dataUrl
        };
        
        saveState();
        annotations[pageNum - 1].push(newAnno);
        
        const img = new Image();
        img.src = dataUrl;
        signatureImageCache.set(dataUrl, img);
        await new Promise(resolve => {
            img.onload = resolve;
            img.onerror = resolve; 
        }); 

        signatureModal.style.display = 'none';
        await redrawAnnotationLayer(annoCanvas, pageNum);
        setTool(toolTextBtn, 'text'); 
    }


    // --- Core PDF Functions (unchanged) ---
    async function openPdfFromFile(file) {
      try { 
        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        pdfDoc = await loadingTask.promise;
        
        annotations = Array.from({ length: pdfDoc.numPages }, () => []);
        signatureImageCache.clear();
        history = [];
        redoHistory = [];
        saveState(); 

        await renderAllPages();
        downloadBtn.disabled = false;
      } catch (error) {
        console.error("PDF Loading Error:", error);
        alert("Error loading PDF. Please check the browser console (F12) for details.");
        pdfViewerWrapper.innerHTML = 'PDF loading failed.';
        pdfDoc = null;
        downloadBtn.disabled = true;
      }
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await openPdfFromFile(file);
    });
    
    // Robust Mouse/Touch -> canvas coordinate conversion (unchanged)
    function getCanvasPos(evt, canvas) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;

      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else if (evt.changedTouches && evt.changedTouches.length > 0) {
        clientX = evt.changedTouches[0].clientX;
        clientY = evt.changedTouches[0].clientY;
      } else if (evt.clientX !== undefined) {
        clientX = evt.clientX;
        clientY = evt.clientY;
      } else {
        return null; 
      }

      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }
    
    // --- Page Event Listeners (unchanged) ---
    function addPageEventListeners(annoCanvas) { 
        const pageNum = parseInt(annoCanvas.dataset.pageNum);
        
        const asyncHandler = (handler) => (e) => {
            if (e.type === 'touchmove') {
                if (isDragging || currentTool === 'highlight' || (dragAnno && dragAnno.type === 'signature')) {
                    e.preventDefault(); 
                }
            }

            handler(e, annoCanvas, pageNum).catch(err => {
                if (err.message && err.message.includes('Cannot use the same canvas during multiple render() operations')) {
                } else {
                     console.error('Unhandled async error in event listener:', err);
                }
            });
        };
        
        annoCanvas.addEventListener('mousedown', asyncHandler(handleMouseDown));
        annoCanvas.addEventListener('mousemove', (e) => handleMouseMove(e, annoCanvas, pageNum)); 
        annoCanvas.addEventListener('mouseup', asyncHandler(handleMouseUp));
        annoCanvas.addEventListener('mouseout', () => { annoCanvas.style.cursor = 'default'; });
        annoCanvas.addEventListener('click', (e) => handleClick(e, annoCanvas, pageNum));
        annoCanvas.addEventListener('dblclick', asyncHandler(handleDoubleClick)); 

        annoCanvas.addEventListener('touchstart', asyncHandler(handleMouseDown));
        annoCanvas.addEventListener('touchmove', (e) => handleMouseMove(e, annoCanvas, pageNum));
        annoCanvas.addEventListener('touchend', asyncHandler(handleMouseUp));
    }
    
    // --- Undo/Redo implementations (unchanged) ---
    async function performUndo() {
        if (history.length > 1) {
            if (activeAnno) await finalizeText(); 

            const currentState = history.pop();
            redoHistory.push(currentState);
            annotations = JSON.parse(JSON.stringify(history[history.length - 1])); 
            
            await renderAllPages(); 
            updateHistoryButtons();
        }
    };
    undoBtn.onclick = performUndo;

    async function performRedo() {
        if (redoHistory.length > 0) {
            if (activeAnno) await finalizeText();
            const nextState = redoHistory.pop();
            history.push(nextState);
            annotations = nextState;
            await renderAllPages();
            updateHistoryButtons();
        }
    }
    redoBtn.onclick = performRedo;

    document.addEventListener('keydown', (e) => {
        const isCtrlOrCmd = e.ctrlKey || e.metaKey;

        if (isCtrlOrCmd) {
            if (e.key === 'z') {
                e.preventDefault(); 
                performUndo();
            } else if (e.key === 'y') {
                e.preventDefault(); 
                performRedo();
            }
        }
    });

    // --- Go To Page Logic (unchanged) ---
    function goToPage(pageNum) {
        if (activeAnno) {
             (async () => { await finalizeText(); })();
        }

        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            pageWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
    
    goToPageBtn.addEventListener('click', () => {
        let pageNum = parseInt(pageInput.value, 10);
        
        if (!pdfDoc) {
            alert('Please upload a PDF first.');
            return;
        }

        if (isNaN(pageNum) || pageNum < 1) {
            pageNum = 1;
        } else if (pageNum > pdfDoc.numPages) {
            pageNum = pdfDoc.numPages;
        }

        pageInput.value = pageNum;
        goToPage(pageNum);
    });

    pageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            goToPageBtn.click();
        }
    });

    // --- Download (unchanged) ---
    async function applyAnnotationsAndDownload() {
      if (!pdfDoc) return;
      
      if (activeAnno) {
          await finalizeText(); 
      }

      const file = fileInput.files[0];
      if (!file) return;
      const originalBuffer = await file.arrayBuffer();

      const { PDFDocument, rgb, StandardFonts } = PDFLib;
      const pdf = await PDFDocument.load(originalBuffer);
      const font = await pdf.embedFont(StandardFonts.Helvetica);

      const firstPage = await pdfDoc.getPage(1);
      const scale = 1.5;
      const firstViewport = firstPage.getViewport({ scale });
      const canvasW = Math.floor(firstViewport.width);
      const canvasH = Math.floor(firstViewport.height);

      for (let i = 0; i < pdf.getPageCount(); i++) {
        const page = pdf.getPage(i);

        const pageWidth = page.getWidth();
        const pageHeight = page.getHeight();
        
        const scaleX = pageWidth / canvasW;
        const scaleY = pageHeight / canvasH;

        const pageAnnos = annotations[i] || [];
        
        const signatureEmbedPromises = [];

        pageAnnos.forEach(a => {
          if (a.type === 'text') {
            const colorHex = a.color;
            const r = parseInt(colorHex.slice(1, 3), 16) / 255;
            const g = parseInt(colorHex.slice(3, 5), 16) / 255;
            const b = parseInt(colorHex.slice(5, 7), 16) / 255;
            
            const lines = a.text.split('\n');
            const fontSize = a.fontSize || 14;
            const lineHeight = fontSize * 1.2;
            
            lines.forEach((line, index) => {
                const x = a.x * scaleX;
                const yCanvas = a.y + fontSize + index * lineHeight; 
                const y = pageHeight - (yCanvas * scaleY); 
                
                page.drawText(line, {
                  x,
                  y,
                  size: fontSize,
                  font,
                  color: rgb(r, g, b)
                });
            });
          } else if (a.type === 'highlight') {
            const colorHex = a.color;
            const r = parseInt(colorHex.slice(1, 3), 16) / 255;
            const g = parseInt(colorHex.slice(3, 5), 16) / 255;
            const b = parseInt(colorHex.slice(5, 7), 16) / 255;
            
            const x = a.x * scaleX;
            const yTopCanvas = a.y;
            const y = pageHeight - ((yTopCanvas + a.h) * scaleY);
            const w = a.w * scaleX;
            const h = a.h * scaleY;

            page.drawRectangle({
              x, y, width: w, height: h,
              color: rgb(r, g, b),
              opacity: 0.35,
              borderWidth: 0
            });
          } else if (a.type === 'signature') {
              signatureEmbedPromises.push(async () => {
                  const pngImage = await pdf.embedPng(a.dataUrl); 
                  
                  const x = a.x * scaleX;
                  const yTopCanvas = a.y; 
                  const y = pageHeight - ((yTopCanvas + a.h) * scaleY); 
                  const w = a.w * scaleX;
                  const h = a.h * scaleY;

                  page.drawImage(pngImage, {
                      x: x, 
                      y: y, 
                      width: w, 
                      height: h,
                      opacity: 1.0, 
                  });
              });
          }
        });

        await Promise.all(signatureEmbedPromises.map(p => p()));
      }

      const pdfBytes = await pdf.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      const name = (file && file.name) ? file.name.replace(/\.pdf$/i, '') : 'document';
      a.download = `${name}-annotated.pdf`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    downloadBtn.onclick = applyAnnotationsAndDownload;
  </script>
</body>
</html>